@using GameBoy.Blazor.Services
@inject ISettingsService SettingsService
@inject IJSRuntime JS
@implements IDisposable

<div class="input-remapping">
    <h6>Input Mapping</h6>
    
    <div class="input-mapping-grid">
        @foreach (var button in _gameButtons)
        {
            <div class="input-item">
                <label style="font-size: 0.9rem; color: var(--text-secondary);">@button:</label>
                <button class="btn-modern @(button == _listeningFor ? "listening" : "")"
                        style="font-family: 'Monaco', 'Consolas', monospace; font-size: 0.8rem; min-height: 32px;"
                        @onclick="() => StartListening(button)"
                        disabled="@(_listeningFor != null && _listeningFor != button)"
                        aria-label="Map key for @button">
                    @(_mappings.TryGetValue(button, out var key) ? FormatKey(key) : "Unbound")
                </button>
            </div>
        }
    </div>
    
    @if (_listeningFor != null)
    {
        <div style="margin-top: 1rem; padding: 0.75rem; background: var(--bg-primary); border-radius: var(--border-radius); border: 1px solid var(--accent-primary);">
            <small style="color: var(--accent-primary);">
                <span class="blink" style="display: inline-block; width: 8px; height: 8px; background: var(--accent-primary); border-radius: 50%; margin-right: 0.5rem;"></span>
                Press a key for <strong>@_listeningFor</strong> (Escape to cancel)
            </small>
        </div>
    }
    
    <div style="margin-top: 1rem;">
        <button class="btn-modern btn-warning" @onclick="ResetToDefaults" aria-label="Reset input mappings to defaults">
            🔄 Reset to Defaults
        </button>
    </div>
</div>

@code {
    [Parameter] public EventCallback<Dictionary<string, string>> OnMappingsChanged { get; set; }
    
    private readonly string[] _gameButtons = { "Up", "Down", "Left", "Right", "A", "B", "Start", "Select" };
    private Dictionary<string, string> _mappings = new();
    private string? _listeningFor;
    private bool _isListening = false;

    protected override async Task OnInitializedAsync()
    {
        _mappings = await SettingsService.GetInputMappingsAsync();
    }

    private void StartListening(string button)
    {
        if (_isListening && _listeningFor == button)
        {
            // Stop listening if clicking the same button
            StopListening();
            return;
        }
        
        _listeningFor = button;
        _isListening = true;
        StateHasChanged();
    }

    private void StopListening()
    {
        _listeningFor = null;
        _isListening = false;
        StateHasChanged();
    }

    private async Task ResetToDefaults()
    {
        var defaultMappings = new Dictionary<string, string>
        {
            { "Up", "ArrowUp" },
            { "Down", "ArrowDown" },
            { "Left", "ArrowLeft" },
            { "Right", "ArrowRight" },
            { "A", "z" },
            { "B", "x" },
            { "Start", "Enter" },
            { "Select", "Shift" }
        };
        
        _mappings = defaultMappings;
        await SettingsService.SetInputMappingsAsync(_mappings);
        await OnMappingsChanged.InvokeAsync(_mappings);
        StateHasChanged();
    }

    private static string FormatKey(string key)
    {
        if (string.IsNullOrEmpty(key)) return "Unbound";
        
        return key switch
        {
            "ArrowUp" => "↑",
            "ArrowDown" => "↓",
            "ArrowLeft" => "←",
            "ArrowRight" => "→",
            "Enter" => "⏎",
            "Shift" => "⇧",
            " " => "Space",
            _ => key.Length == 1 ? key.ToUpper() : key
        };
    }
    
    public void Dispose()
    {
        // Cleanup if needed
    }
}

<style>
    .input-remapping .listening {
        background: rgba(0, 212, 170, 0.1) !important;
        border-color: var(--accent-primary) !important;
    }
    
    .blink {
        animation: blink 1s infinite;
    }
    
    @@keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0.3; }
    }
</style>