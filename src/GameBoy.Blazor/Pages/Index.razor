@page "/"
@using GameBoy.Core
@using GameBoy.Core.Persistence
@using GameBoy.Blazor.Services
@using GameBoy.Blazor.Components
@using System.IO
@inject Emulator Emulator
@inject IPersistenceService PersistenceService
@inject ISettingsService SettingsService
@inject IJSRuntime JS
@inject NavigationManager Navigation
@implements IDisposable

<!-- Header -->
<div class="emulator-header">
    <div class="header-left">
        <h1><i class="gameboy-icon">üéÆ</i> GameBoy Emulator</h1>
    </div>
    <div class="header-right">
        <button class="btn-header" @onclick="ToggleSettings">
            <i class="settings-icon">‚öôÔ∏è</i>
        </button>
        <div class="rom-loader-header">
            <RomLoader OnRomLoaded="OnRomLoaded" @ref="_romLoader" />
        </div>
    </div>
</div>

<!-- Main Two-Panel Layout -->
<div class="emulator-main">
    <!-- Left Panel - Game Screen -->
    <div class="game-panel">
        <div class="game-screen-frame">
            <!-- Status Dots -->
            <div class="status-dots">
                <div class="status-dot red"></div>
                <div class="status-dot yellow"></div>
                <div class="status-dot green"></div>
            </div>
            
            <!-- Screen Label -->
            <div class="screen-label">NINTENDO GAME BOY</div>
            
            <!-- Game Screen -->
            <div class="game-screen-container">
                <div class="game-canvas-wrapper" tabindex="0" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" @onclick="OnCanvasClick" @ref="_focusable">
                    <canvas id="screen" width="160" height="144" 
                            class="game-canvas"></canvas>
                    
                    <!-- No ROM Loaded Overlay -->
                    @if (!_hasRom)
                    {
                        <div class="no-rom-overlay">
                            <div class="gameboy-icon-large">üéÆ</div>
                            <div class="no-rom-text">NO ROM LOADED</div>
                            <div class="no-rom-subtext">Select cartridge to begin</div>
                        </div>
                    }
                </div>
            </div>
            
            <!-- Control Buttons -->
            <div class="screen-controls">
                <button class="btn-control btn-save" @onclick="SaveState" disabled="@(!_hasRom)">
                    üíæ SAVE STATE
                </button>
                <button class="btn-control btn-load" @onclick="LoadState" disabled="@(!_hasRom)">
                    üìÅ LOAD STATE
                </button>
                <button class="btn-control btn-pause" @onclick="ToggleRunPause" disabled="@(!_hasRom)">
                    @(_isRunning ? "‚è∏Ô∏è PAUSE" : "‚ñ∂Ô∏è PLAY")
                </button>
            </div>
            
            <!-- Status Bar -->
            <div class="status-bar">
                <div class="status-item">
                    <span class="status-label">STATUS:</span>
                    <span class="status-value">@(_hasRom ? (_isRunning ? "Running" : "Paused") : "Ready")</span>
                </div>
                <div class="status-item">
                    <span class="status-label">FPS:</span>
                    <span class="status-value">@(_lastFps.ToString("F0"))</span>
                </div>
                <div class="status-item">
                    <span class="status-label">BATTERY:</span>
                    <div class="battery-indicator">
                        <div class="battery-level" style="width: @(Emulator.HasBatteryRam ? "100%" : "0%")"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Panel - Controls -->
    <div class="controls-panel">
        <!-- Game Controls -->
        <div class="control-section">
            <h3>GAME CONTROLS</h3>
            <div class="game-controls">
                <div class="dpad-container">
                    <div class="dpad">
                        <button class="dpad-btn dpad-up" @onmousedown="@(() => OnDirectionalInput("Up", true))" @onmouseup="@(() => OnDirectionalInput("Up", false))">‚¨Ü</button>
                        <button class="dpad-btn dpad-left" @onmousedown="@(() => OnDirectionalInput("Left", true))" @onmouseup="@(() => OnDirectionalInput("Left", false))">‚¨Ö</button>
                        <button class="dpad-btn dpad-center"></button>
                        <button class="dpad-btn dpad-right" @onmousedown="@(() => OnDirectionalInput("Right", true))" @onmouseup="@(() => OnDirectionalInput("Right", false))">‚û°</button>
                        <button class="dpad-btn dpad-down" @onmousedown="@(() => OnDirectionalInput("Down", true))" @onmouseup="@(() => OnDirectionalInput("Down", false))">‚¨á</button>
                    </div>
                </div>
                <div class="action-buttons">
                    <button class="action-btn btn-b" @onmousedown="@(() => OnActionInput("B", true))" @onmouseup="@(() => OnActionInput("B", false))">B</button>
                    <button class="action-btn btn-a" @onmousedown="@(() => OnActionInput("A", true))" @onmouseup="@(() => OnActionInput("A", false))">A</button>
                </div>
                <div class="system-buttons">
                    <button class="system-btn" @onmousedown="@(() => OnActionInput("Select", true))" @onmouseup="@(() => OnActionInput("Select", false))">SELECT</button>
                    <button class="system-btn" @onmousedown="@(() => OnActionInput("Start", true))" @onmouseup="@(() => OnActionInput("Start", false))">START</button>
                </div>
            </div>
        </div>

        <!-- Quick Settings -->
        <div class="control-section">
            <h3>QUICK SETTINGS</h3>
            <div class="settings-grid">
                <div class="setting-row">
                    <label>Sound</label>
                    <div class="toggle-switch">
                        <input type="checkbox" @bind="_audioEnabled" @oninput="OnAudioToggle" />
                        <span class="toggle-slider"></span>
                    </div>
                </div>
                <div class="setting-row">
                    <label>Fullscreen</label>
                    <div class="toggle-switch">
                        <input type="checkbox" @bind="_fullscreenEnabled" @oninput="OnFullscreenToggle" />
                        <span class="toggle-slider"></span>
                    </div>
                </div>
                <div class="setting-row">
                    <label>Screen Size</label>
                    <select class="setting-select" @bind="_screenSize" @oninput="OnScreenSizeChange">
                        <option value="1x">Pixel Perfect</option>
                        <option value="2x" selected>Standard</option>
                        <option value="3x">Large</option>
                        <option value="fit">Fit Screen</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label>Filter Presets</label>
                    <select class="setting-select" @bind="_filterPreset" @oninput="OnFilterChange">
                        <option value="none" selected>None</option>
                        <option value="scanlines">Scanlines</option>
                        <option value="crt">CRT</option>
                        <option value="smooth">Smooth</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Color Palette -->
        <div class="control-section">
            <h3>COLOR PALETTE</h3>
            <div class="color-palette">
                <div class="palette-option @(_selectedPalette == "classic" ? "selected" : "")" @onclick="@(() => SelectPalette("classic"))">
                    <div class="color-sample classic-palette"></div>
                </div>
                <div class="palette-option @(_selectedPalette == "orange" ? "selected" : "")" @onclick="@(() => SelectPalette("orange"))">
                    <div class="color-sample orange-palette"></div>
                </div>
                <div class="palette-option @(_selectedPalette == "blue" ? "selected" : "")" @onclick="@(() => SelectPalette("blue"))">
                    <div class="color-sample blue-palette"></div>
                </div>
                <div class="palette-option @(_selectedPalette == "teal" ? "selected" : "")" @onclick="@(() => SelectPalette("teal"))">
                    <div class="color-sample teal-palette"></div>
                </div>
            </div>
        </div>

        <!-- Save States -->
        <div class="control-section">
            <h3>SAVE STATES</h3>
            <div class="save-slots">
                <div class="save-slot @(_saveSlot1Used ? "used" : "empty")" @onclick="@(() => SelectSaveSlot(1))">
                    <div class="slot-icon">üíæ</div>
                    <div class="slot-info">
                        <div class="slot-title">Slot 1</div>
                        <div class="slot-subtitle">@(_saveSlot1Used ? "Saved 2 minutes ago" : "Empty")</div>
                    </div>
                </div>
                <div class="save-slot empty" @onclick="@(() => SelectSaveSlot(2))">
                    <div class="slot-icon">üíæ</div>
                    <div class="slot-info">
                        <div class="slot-title">Slot 2</div>
                        <div class="slot-subtitle">Empty</div>
                    </div>
                </div>
                <div class="save-slot empty" @onclick="@(() => SelectSaveSlot(3))">
                    <div class="slot-icon">üíæ</div>
                    <div class="slot-info">
                        <div class="slot-title">Slot 3</div>
                        <div class="slot-subtitle">Empty</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Performance -->
        <div class="control-section">
            <h3>PERFORMANCE</h3>
            <div class="performance-info">
                <div class="perf-item">
                    <label>CPU Usage</label>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: @(_lastFps > 50 ? "75%" : "45%")"></div>
                    </div>
                    <span class="perf-value">@(_lastFps > 50 ? "75%" : "45%")</span>
                </div>
                <div class="perf-item">
                    <label>Memory</label>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 60%"></div>
                    </div>
                    <span class="perf-value">60%</span>
                </div>
                <div class="perf-item">
                    <label>Frame Rate</label>
                    <div class="fps-display">@(_lastFps.ToString("F0")) FPS</div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    // Component references
    private RomLoader? _romLoader;

    // Core emulator state
    private DotNetObjectReference<Index>? _dotNetRef;
    private ElementReference _focusable;
    private bool _hasRom = false;
    private bool _isRunning = false;
    private bool _isInTestMode = false;
    private double _speedMultiplier = 1.0;
    private Dictionary<string, string> _inputMappings = new();

    // FPS tracking
    private double _lastFps;
    private long _lastTs;
    
    // Enhanced adaptive performance system
    private int _currentCyclesPerFrame = 17500; // Start conservatively at 25% accuracy for WebAssembly
    private const int FullAccuracyCycles = 70224; // Full Game Boy accuracy
    private const int MinCyclesPerFrame = 12000; // ~17% accuracy for emergency performance mode
    private const double TargetFps = 35.0; // More realistic target for WebAssembly
    private const double FpsAdjustmentThreshold = 3.0; // Smaller threshold for faster response
    private const double EmergencyFpsThreshold = 15.0; // Emergency threshold for immediate scaling
    private int _performanceFrameCounter = 0;
    private const int PerformanceAdjustmentInterval = 10; // Adjust every 10 frames (~0.17 seconds) for faster response
    private double _recentFpsHistory = 0.0; // Track recent FPS for smoother adjustments

    // Debug
    private bool _showDebugInfo = false;
    private string _debugInfo = "";

    // UI state
    private bool _showSettingsOverlay = false;
    private bool _audioEnabled = true;
    private bool _fullscreenEnabled = false;
    private string _screenSize = "2x";
    private string _filterPreset = "none";
    private string _selectedPalette = "classic";
    
    // Save state
    private string? _currentRomKey;
    private string? _saveStateMessage;
    private bool _saveStateSuccess;
    private bool _saveSlot1Used = false;
    private bool _saveSlot2Used = false;
    private bool _saveSlot3Used = false;

    protected override async Task OnInitializedAsync()
    {
        // Load settings
        _speedMultiplier = await SettingsService.GetSpeedMultiplierAsync();
        _inputMappings = await SettingsService.GetInputMappingsAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            
            // Draw initial frame to ensure canvas shows default background color
            await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
            
            await JS.InvokeVoidAsync("gbInterop.startRenderLoop", _dotNetRef);
            await _focusable.FocusAsync();
        }
    }

    [JSInvokable]
    public async Task<bool> OnAnimationFrame(double timestamp)
    {
        if (_lastTs == 0)
            _lastTs = (long)timestamp;
        var delta = timestamp - _lastTs;
        _lastTs = (long)timestamp;
        if (delta > 0)
            _lastFps = 1000.0 / delta;

        // Skip emulation if we're in test mode or paused
        if (!_isInTestMode && _isRunning && _hasRom)
        {
            // Adaptive performance adjustment
            _performanceFrameCounter++;
            if (_performanceFrameCounter >= PerformanceAdjustmentInterval)
            {
                AdjustPerformanceBasedOnFps();
                _performanceFrameCounter = 0;
            }
            
            // Apply speed multiplier with adaptive cycles
            int cyclesPerFrame = (int)(_currentCyclesPerFrame * _speedMultiplier);
            bool frameReady = Emulator.StepFrame(cyclesPerFrame);
            
            if (frameReady)
            {
                await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
            }

            // Update audio if enabled
            await UpdateAudioBuffer();
        }
        
        StateHasChanged();
        return true; // continue loop
    }

    private async Task UpdateAudioBuffer()
    {
        try
        {
            var samples = Emulator.Apu.PullSamples();
            if (samples.Length > 0)
            {
                await JS.InvokeVoidAsync("gbInterop.updateAudioBuffer", samples);
            }
        }
        catch (JSException)
        {
            // Audio might not be initialized yet - this is normal
        }
    }

    // UI Control Methods
    private void ToggleSettings()
    {
        _showSettingsOverlay = !_showSettingsOverlay;
    }

    private void OnDirectionalInput(string direction, bool pressed)
    {
        switch (direction)
        {
            case "Up": Emulator.Joypad.Up = pressed; break;
            case "Down": Emulator.Joypad.Down = pressed; break;
            case "Left": Emulator.Joypad.Left = pressed; break;
            case "Right": Emulator.Joypad.Right = pressed; break;
        }
    }

    private void OnActionInput(string action, bool pressed)
    {
        switch (action)
        {
            case "A": Emulator.Joypad.A = pressed; break;
            case "B": Emulator.Joypad.B = pressed; break;
            case "Start": Emulator.Joypad.Start = pressed; break;
            case "Select": Emulator.Joypad.Select = pressed; break;
        }
    }

    private void OnAudioToggle()
    {
        // Audio toggle logic
    }

    private void OnFullscreenToggle()
    {
        // Fullscreen toggle logic
    }

    private void OnScreenSizeChange()
    {
        // Screen size change logic
    }

    private void OnFilterChange()
    {
        // Filter change logic
    }

    private void SelectPalette(string palette)
    {
        _selectedPalette = palette;
        // Palette change logic
    }

    private void SelectSaveSlot(int slot)
    {
        // Save slot selection logic
    }

    // ROM loading with adaptive performance initialization
    private async Task OnRomLoaded((byte[] data, string fileName) romData)
    {
        // Save current battery RAM before loading new ROM
        await SaveCurrentBatteryRam();
        
        // Generate ROM key for persistence
        _currentRomKey = BatteryStore.GenerateRomKey(romData.data);
        
        // Load new ROM
        Emulator.LoadRom(romData.data);
        
        // Load battery RAM for this ROM if it exists
        await LoadBatteryRamForCurrentRom();
        
        // Initialize adaptive performance based on ROM complexity
        InitializeAdaptivePerformanceForRom(romData.fileName);
        
        _hasRom = true;
        _isRunning = true; // Auto-start when ROM loads
        _isInTestMode = false;
        
        StateHasChanged();
    }
    
    /// <summary>
    /// Initialize performance settings based on ROM complexity
    /// </summary>
    private void InitializeAdaptivePerformanceForRom(string fileName)
    {
        // Reset performance tracking
        _performanceFrameCounter = 0;
        _recentFpsHistory = 0.0;
        
        // Detect complex ROMs that need conservative initial settings
        string lowerFileName = fileName.ToLowerInvariant();
        if (lowerFileName.Contains("tetris") || 
            lowerFileName.Contains("zelda") || 
            lowerFileName.Contains("mario") ||
            lowerFileName.Contains("pokemon"))
        {
            // Start very conservatively for complex ROMs
            _currentCyclesPerFrame = MinCyclesPerFrame;
            Console.WriteLine($"Complex ROM detected ({fileName}): Starting with minimum cycles {_currentCyclesPerFrame}");
        }
        else
        {
            // Standard starting point for simpler ROMs
            _currentCyclesPerFrame = 17500; // 25% accuracy
            Console.WriteLine($"Standard ROM loaded ({fileName}): Starting with {_currentCyclesPerFrame} cycles");
        }
    }

    // Emulator control
    private void ToggleRunPause()
    {
        _isRunning = !_isRunning;
    }

    private void ResetEmulator()
    {
        if (_hasRom)
        {
            Emulator.Reset();
            _isRunning = true;
        }
    }

    private async Task OnSpeedChanged(double speed)
    {
        _speedMultiplier = speed;
        await SettingsService.SetSpeedMultiplierAsync(speed);
    }

    /// <summary>
    /// Enhanced adaptive performance adjustment with aggressive WebAssembly optimization
    /// </summary>
    private void AdjustPerformanceBasedOnFps()
    {
        if (_lastFps <= 0) return; // No FPS data yet
        
        // Update FPS history for smoother adjustments
        _recentFpsHistory = _recentFpsHistory * 0.7 + _lastFps * 0.3;
        double workingFps = _recentFpsHistory > 0 ? _recentFpsHistory : _lastFps;
        
        // Emergency scaling for severe performance issues
        if (workingFps < EmergencyFpsThreshold && _currentCyclesPerFrame > MinCyclesPerFrame)
        {
            // Immediately drop to minimum for recovery
            _currentCyclesPerFrame = MinCyclesPerFrame;
            Console.WriteLine($"Emergency scaling: FPS {workingFps:F1} -> Cycles reduced to {_currentCyclesPerFrame}");
            return;
        }
        
        double fpsDifference = workingFps - TargetFps;
        
        // Aggressive performance mode - larger adjustments for poor performance
        if (fpsDifference < -FpsAdjustmentThreshold && _currentCyclesPerFrame > MinCyclesPerFrame)
        {
            // Scale reduction based on how far below target we are
            double severityFactor = Math.Max(1.0, Math.Abs(fpsDifference) / 10.0);
            int baseReduction = Math.Max(1500, _currentCyclesPerFrame / 8); // Larger base reduction
            int reduction = (int)(baseReduction * severityFactor);
            
            _currentCyclesPerFrame = Math.Max(MinCyclesPerFrame, _currentCyclesPerFrame - reduction);
            Console.WriteLine($"Performance mode: FPS {workingFps:F1} -> Cycles reduced by {reduction} to {_currentCyclesPerFrame}");
        }
        // Conservative accuracy mode - smaller increases for good performance
        else if (fpsDifference > FpsAdjustmentThreshold && _currentCyclesPerFrame < FullAccuracyCycles)
        {
            // Only increase if we're well above target with sustained good performance
            if (workingFps > TargetFps + 8.0) // Require 8+ FPS above target for increases
            {
                int increase = Math.Max(800, _currentCyclesPerFrame / 15); // Smaller, careful increases
                _currentCyclesPerFrame = Math.Min(FullAccuracyCycles, _currentCyclesPerFrame + increase);
                Console.WriteLine($"Accuracy mode: FPS {workingFps:F1} -> Cycles increased by {increase} to {_currentCyclesPerFrame}");
            }
        }
        
        // Cap cycles based on sustained performance
        double accuracyPercent = (_currentCyclesPerFrame / (double)FullAccuracyCycles) * 100;
        Console.WriteLine($"Adaptive performance: {accuracyPercent:F1}% accuracy, {workingFps:F1} FPS");
    }

    // Audio control
    private void OnAudioStateChanged(bool enabled)
    {
        // Audio state is managed by the AudioToggle component
    }

    private void OnVolumeChanged(double volume)
    {
        // Volume is managed by the AudioToggle component
    }

    // Input handling
    private void OnKeyDown(KeyboardEventArgs e) => UpdateJoypad(e, true);
    private void OnKeyUp(KeyboardEventArgs e) => UpdateJoypad(e, false);

    private void UpdateJoypad(KeyboardEventArgs e, bool down)
    {
        // Use current input mappings
        foreach (var mapping in _inputMappings)
        {
            if (mapping.Value == e.Key)
            {
                switch (mapping.Key)
                {
                    case "Up": Emulator.Joypad.Up = down; break;
                    case "Down": Emulator.Joypad.Down = down; break;
                    case "Left": Emulator.Joypad.Left = down; break;
                    case "Right": Emulator.Joypad.Right = down; break;
                    case "A": Emulator.Joypad.A = down; break;
                    case "B": Emulator.Joypad.B = down; break;
                    case "Start": Emulator.Joypad.Start = down; break;
                    case "Select": Emulator.Joypad.Select = down; break;
                }
                break;
            }
        }
    }

    private void OnCanvasClick()
    {
        _isInTestMode = false; // Resume emulation when user clicks canvas
    }

    // Save state functionality (preserved from original)
    private async Task SaveCurrentBatteryRam()
    {
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = Emulator.GetBatteryRam();
                await PersistenceService.SaveBatteryRamAsync(_currentRomKey, batteryData);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to save battery RAM: {ex.Message}");
            }
        }
    }

    private async Task LoadBatteryRamForCurrentRom()
    {
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = await PersistenceService.LoadBatteryRamAsync(_currentRomKey);
                if (batteryData != null)
                {
                    Emulator.LoadBatteryRam(batteryData);
                    Console.WriteLine($"Loaded battery RAM for {_currentRomKey} ({batteryData.Length} bytes)");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load battery RAM: {ex.Message}");
            }
        }
    }

    private async Task SaveState()
    {
        if (_currentRomKey == null)
        {
            ShowSaveStateMessage("No ROM loaded", false);
            return;
        }

        try
        {
            byte[] saveStateData = Emulator.SerializeSaveState();
            string slotKey = $"{_currentRomKey}_quick";
            
            bool success = await PersistenceService.SaveSaveStateAsync(slotKey, saveStateData);
            if (success)
            {
                ShowSaveStateMessage($"State saved ({saveStateData.Length} bytes)", true);
            }
            else
            {
                ShowSaveStateMessage("Failed to save state", false);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Save state error: {ex.Message}");
            ShowSaveStateMessage($"Error: {ex.Message}", false);
        }
    }

    private async Task LoadState()
    {
        if (_currentRomKey == null)
        {
            ShowSaveStateMessage("No ROM loaded", false);
            return;
        }

        try
        {
            string slotKey = $"{_currentRomKey}_quick";
            byte[]? saveStateData = await PersistenceService.LoadSaveStateAsync(slotKey);
            
            if (saveStateData == null)
            {
                ShowSaveStateMessage("No save state found", false);
                return;
            }

            Emulator.DeserializeSaveState(saveStateData);
            ShowSaveStateMessage($"State loaded ({saveStateData.Length} bytes)", true);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load state error: {ex.Message}");
            ShowSaveStateMessage($"Error: {ex.Message}", false);
        }
    }

    private void ShowSaveStateMessage(string message, bool success)
    {
        _saveStateMessage = message;
        _saveStateSuccess = success;
        StateHasChanged();

        // Clear message after 3 seconds
        _ = Task.Delay(3000).ContinueWith(t =>
        {
            if (_saveStateMessage == message) // Only clear if it's still the same message
            {
                _saveStateMessage = null;
                InvokeAsync(StateHasChanged);
            }
        });
    }

    // Debug functionality with Tetris loading for testing
    private async Task LoadTetrisForTesting()
    {
        try
        {
            // For testing purposes, create a simulation of Tetris performance
            // since direct file access isn't available in WebAssembly
            Console.WriteLine("Loading performance test simulation...");
            
            // Create a minimal test ROM that will exercise the emulator
            byte[] testRom = CreatePerformanceTestRom();
            await OnRomLoaded((testRom, "PerformanceTest.gb"));
            Console.WriteLine("Performance test ROM loaded - simulating complex game behavior");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load performance test: {ex.Message}");
        }
    }
    
    /// <summary>
    /// Creates a minimal ROM that exercises the emulator for performance testing
    /// </summary>
    private byte[] CreatePerformanceTestRom()
    {
        // Create a minimal 32KB ROM with header and some basic instructions
        byte[] rom = new byte[32768];
        
        // ROM header (at 0x100-0x14F)
        rom[0x0143] = 0x00; // CGB flag - DMG only
        rom[0x0147] = 0x00; // MBC type - ROM only
        rom[0x0148] = 0x00; // ROM size - 32KB
        rom[0x0149] = 0x00; // RAM size - none
        
        // Calculate header checksum
        int checksum = 0;
        for (int i = 0x0134; i < 0x014D; i++)
        {
            checksum = checksum - rom[i] - 1;
        }
        rom[0x014D] = (byte)(checksum & 0xFF);
        
        // Entry point (0x0100) - jump to main code
        rom[0x0100] = 0xC3; // JP instruction
        rom[0x0101] = 0x50; // Low byte of address 0x0150
        rom[0x0102] = 0x01; // High byte of address 0x0150
        
        // Main code loop (0x0150+) - create a busy loop that exercises CPU
        int addr = 0x0150;
        rom[addr++] = 0x21; // LD HL, 0x9800 (VRAM)
        rom[addr++] = 0x00;
        rom[addr++] = 0x98;
        
        rom[addr++] = 0x06; // LD B, 0xFF
        rom[addr++] = 0xFF;
        
        // Loop start
        rom[addr++] = 0x36; // LD (HL), value
        rom[addr++] = 0xAA;
        rom[addr++] = 0x23; // INC HL
        rom[addr++] = 0x05; // DEC B
        rom[addr++] = 0x20; // JR NZ, -4
        rom[addr++] = 0xFC;
        
        rom[addr++] = 0x18; // JR -10 (infinite loop)
        rom[addr++] = 0xF6;
        
        return rom;
    }
    
    private async Task CreateTestPattern()
    {
        _isInTestMode = true; // Pause emulation
        Emulator.CreateTestPattern();
        // Immediately update the canvas to show the test pattern
        await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
    }

    private async Task CreateDirectTestPattern()
    {
        _isInTestMode = true; // Pause emulation
        Emulator.CreateDirectTestPattern();
        // Immediately update the canvas to show the test pattern
        await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
    }

    private void ShowDebugInfo()
    {
        _debugInfo = Emulator.GetDebugInfo();
        _showDebugInfo = !_showDebugInfo;
    }

    private void NavigateToDebugPage()
    {
        Navigation.NavigateTo("/debug");
    }



    public void Dispose()
    {
        _dotNetRef?.Dispose();
        
        // Save battery RAM before disposing
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = Emulator.GetBatteryRam();
                // Note: This is sync because Dispose can't be async
                // The data will be saved on next visit if this fails
                _ = Task.Run(async () => await PersistenceService.SaveBatteryRamAsync(_currentRomKey, batteryData));
            }
            catch
            {
                // Ignore errors during dispose
            }
        }
    }
}