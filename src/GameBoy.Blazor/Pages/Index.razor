@page "/"
@using GameBoy.Core
@using GameBoy.Core.Persistence
@using GameBoy.Blazor.Services
@using GameBoy.Blazor.Components
@inject Emulator Emulator
@inject IPersistenceService PersistenceService
@inject ISettingsService SettingsService
@inject IJSRuntime JS
@implements IDisposable

<div class="container-fluid">
    <div class="row">
        <div class="col">
            <h1>Game Boy (Blazor)</h1>
        </div>
    </div>

    <!-- Main Control Panel -->
    <div class="card mb-3">
        <div class="card-body">
            <div class="row g-3 align-items-center">
                <!-- ROM Loader -->
                <div class="col-md-3">
                    <RomLoader OnRomLoaded="OnRomLoaded" @ref="_romLoader" />
                </div>

                <!-- Emulator Controls -->
                <div class="col-md-3">
                    <EmulatorControls HasRom="_hasRom" 
                                    IsRunning="_isRunning"
                                    OnToggleRunPause="ToggleRunPause"
                                    OnReset="ResetEmulator"
                                    OnSpeedChangeCallback="OnSpeedChanged" 
                                    @ref="_emulatorControls" />
                </div>

                <!-- Audio Controls -->
                <div class="col-md-3">
                    <AudioToggle OnAudioStateChanged="OnAudioStateChanged"
                               OnVolumeChangeCallback="OnVolumeChanged" 
                               @ref="_audioToggle" />
                </div>

                <!-- FPS Counter -->
                <div class="col-md-3">
                    <FpsCounter CurrentFps="_lastFps" @ref="_fpsCounter" />
                </div>
            </div>
        </div>
    </div>

    <!-- Game Screen and Debug Section -->
    <div class="row">
        <div class="col-lg-8">
            <!-- Game Canvas -->
            <div class="card">
                <div class="card-body text-center">
                    <div tabindex="0" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" @onclick="OnCanvasClick" @ref="_focusable">
                        <canvas id="screen" width="160" height="144" 
                                style="image-rendering: pixelated; width: 320px; height: 288px; border:1px solid #ccc; background: #9bbc0f"></canvas>
                        <div class="mt-2">
                            <small class="text-muted">Click canvas and use keyboard controls</small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Save States -->
            <div class="card mt-3">
                <div class="card-body">
                    <h6 class="card-title">Save States</h6>
                    <div class="d-flex gap-2 align-items-center">
                        <button class="btn btn-sm btn-success" @onclick="SaveState" disabled="@(!_hasRom)">
                            üíæ Save State
                        </button>
                        <button class="btn btn-sm btn-primary" @onclick="LoadState" disabled="@(!_hasRom)">
                            üìÅ Load State
                        </button>
                        @if (_saveStateMessage != null)
                        {
                            <small class="ms-2 @(_saveStateSuccess ? "text-success" : "text-danger")">@_saveStateMessage</small>
                        }
                    </div>
                </div>
            </div>
        </div>

        <div class="col-lg-4">
            <!-- Input Remapping -->
            <div class="card mb-3">
                <div class="card-body">
                    <InputRemapping OnMappingsChanged="OnInputMappingsChanged" @ref="_inputRemapping" />
                </div>
            </div>

            <!-- Debug Section -->
            <div class="card">
                <div class="card-body">
                    <h6 class="card-title">Debug Tools</h6>
                    <div class="d-flex flex-wrap gap-2">
                        <button class="btn btn-sm btn-outline-secondary" @onclick="CreateTestPattern">Test VRAM</button>
                        <button class="btn btn-sm btn-outline-secondary" @onclick="CreateDirectTestPattern">Test Direct</button>
                        <button class="btn btn-sm btn-outline-info" @onclick="ShowDebugInfo">Debug Info</button>
                    </div>
                    
                    @if (_showDebugInfo)
                    {
                        <div class="mt-3">
                            <pre style="font-size: 0.8em; background-color: #f8f9fa; padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto;">@_debugInfo</pre>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Touch Overlay for Mobile -->
<TouchOverlay OnButtonStateChanged="OnTouchInput" @ref="_touchOverlay" />

@code {
    // Component references
    private RomLoader? _romLoader;
    private EmulatorControls? _emulatorControls;
    private AudioToggle? _audioToggle;
    private FpsCounter? _fpsCounter;
    private InputRemapping? _inputRemapping;
    private TouchOverlay? _touchOverlay;

    // Core emulator state
    private DotNetObjectReference<Index>? _dotNetRef;
    private ElementReference _focusable;
    private bool _hasRom = false;
    private bool _isRunning = false;
    private bool _isInTestMode = false;
    private double _speedMultiplier = 1.0;
    private Dictionary<string, string> _inputMappings = new();

    // FPS tracking
    private double _lastFps;
    private long _lastTs;

    // Debug
    private bool _showDebugInfo = false;
    private string _debugInfo = "";

    // Save state
    private string? _currentRomKey;
    private string? _saveStateMessage;
    private bool _saveStateSuccess;

    protected override async Task OnInitializedAsync()
    {
        // Load settings
        _speedMultiplier = await SettingsService.GetSpeedMultiplierAsync();
        _inputMappings = await SettingsService.GetInputMappingsAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            
            // Draw initial frame to ensure canvas shows default background color
            await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
            
            await JS.InvokeVoidAsync("gbInterop.startRenderLoop", _dotNetRef);
            await _focusable.FocusAsync();
        }
    }

    [JSInvokable]
    public async Task<bool> OnAnimationFrame(double timestamp)
    {
        if (_lastTs == 0)
            _lastTs = (long)timestamp;
        var delta = timestamp - _lastTs;
        _lastTs = (long)timestamp;
        if (delta > 0)
            _lastFps = 1000.0 / delta;

        // Skip emulation if we're in test mode or paused
        if (!_isInTestMode && _isRunning && _hasRom)
        {
            // Apply speed multiplier
            int cyclesPerFrame = (int)(17500 * _speedMultiplier); // Adjusted for speed
            bool frameReady = Emulator.StepFrame(cyclesPerFrame);
            
            if (frameReady)
            {
                await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
            }

            // Update audio if enabled
            await UpdateAudioBuffer();
        }
        
        StateHasChanged();
        return true; // continue loop
    }

    private async Task UpdateAudioBuffer()
    {
        try
        {
            var samples = Emulator.Apu.PullSamples();
            if (samples.Length > 0)
            {
                await JS.InvokeVoidAsync("gbInterop.updateAudioBuffer", samples);
            }
        }
        catch (JSException)
        {
            // Audio might not be initialized yet - this is normal
        }
    }

    // ROM loading
    private async Task OnRomLoaded((byte[] data, string fileName) romData)
    {
        // Save current battery RAM before loading new ROM
        await SaveCurrentBatteryRam();
        
        // Generate ROM key for persistence
        _currentRomKey = BatteryStore.GenerateRomKey(romData.data);
        
        // Load new ROM
        Emulator.LoadRom(romData.data);
        
        // Load battery RAM for this ROM if it exists
        await LoadBatteryRamForCurrentRom();
        
        _hasRom = true;
        _isRunning = true; // Auto-start when ROM loads
        _isInTestMode = false;
        
        StateHasChanged();
    }

    // Emulator control
    private void ToggleRunPause()
    {
        _isRunning = !_isRunning;
    }

    private void ResetEmulator()
    {
        if (_hasRom)
        {
            Emulator.Reset();
            _isRunning = true;
        }
    }

    private async Task OnSpeedChanged(double speed)
    {
        _speedMultiplier = speed;
        await SettingsService.SetSpeedMultiplierAsync(speed);
    }

    // Audio control
    private void OnAudioStateChanged(bool enabled)
    {
        // Audio state is managed by the AudioToggle component
    }

    private void OnVolumeChanged(double volume)
    {
        // Volume is managed by the AudioToggle component
    }

    // Input handling
    private void OnKeyDown(KeyboardEventArgs e) => UpdateJoypad(e, true);
    private void OnKeyUp(KeyboardEventArgs e) => UpdateJoypad(e, false);

    private void UpdateJoypad(KeyboardEventArgs e, bool down)
    {
        // Use current input mappings
        foreach (var mapping in _inputMappings)
        {
            if (mapping.Value == e.Key)
            {
                switch (mapping.Key)
                {
                    case "Up": Emulator.Joypad.Up = down; break;
                    case "Down": Emulator.Joypad.Down = down; break;
                    case "Left": Emulator.Joypad.Left = down; break;
                    case "Right": Emulator.Joypad.Right = down; break;
                    case "A": Emulator.Joypad.A = down; break;
                    case "B": Emulator.Joypad.B = down; break;
                    case "Start": Emulator.Joypad.Start = down; break;
                    case "Select": Emulator.Joypad.Select = down; break;
                }
                break;
            }
        }
    }

    private void OnTouchInput((string button, bool pressed) input)
    {
        // Handle touch input
        switch (input.button)
        {
            case "Up": Emulator.Joypad.Up = input.pressed; break;
            case "Down": Emulator.Joypad.Down = input.pressed; break;
            case "Left": Emulator.Joypad.Left = input.pressed; break;
            case "Right": Emulator.Joypad.Right = input.pressed; break;
            case "A": Emulator.Joypad.A = input.pressed; break;
            case "B": Emulator.Joypad.B = input.pressed; break;
            case "Start": Emulator.Joypad.Start = input.pressed; break;
            case "Select": Emulator.Joypad.Select = input.pressed; break;
        }
    }

    private async Task OnInputMappingsChanged(Dictionary<string, string> mappings)
    {
        _inputMappings = mappings;
        await SettingsService.SetInputMappingsAsync(mappings);
    }

    private void OnCanvasClick()
    {
        _isInTestMode = false; // Resume emulation when user clicks canvas
    }

    // Save state functionality (preserved from original)
    private async Task SaveCurrentBatteryRam()
    {
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = Emulator.GetBatteryRam();
                await PersistenceService.SaveBatteryRamAsync(_currentRomKey, batteryData);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to save battery RAM: {ex.Message}");
            }
        }
    }

    private async Task LoadBatteryRamForCurrentRom()
    {
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = await PersistenceService.LoadBatteryRamAsync(_currentRomKey);
                if (batteryData != null)
                {
                    Emulator.LoadBatteryRam(batteryData);
                    Console.WriteLine($"Loaded battery RAM for {_currentRomKey} ({batteryData.Length} bytes)");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load battery RAM: {ex.Message}");
            }
        }
    }

    private async Task SaveState()
    {
        if (_currentRomKey == null)
        {
            ShowSaveStateMessage("No ROM loaded", false);
            return;
        }

        try
        {
            byte[] saveStateData = Emulator.SerializeSaveState();
            string slotKey = $"{_currentRomKey}_quick";
            
            bool success = await PersistenceService.SaveSaveStateAsync(slotKey, saveStateData);
            if (success)
            {
                ShowSaveStateMessage($"State saved ({saveStateData.Length} bytes)", true);
            }
            else
            {
                ShowSaveStateMessage("Failed to save state", false);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Save state error: {ex.Message}");
            ShowSaveStateMessage($"Error: {ex.Message}", false);
        }
    }

    private async Task LoadState()
    {
        if (_currentRomKey == null)
        {
            ShowSaveStateMessage("No ROM loaded", false);
            return;
        }

        try
        {
            string slotKey = $"{_currentRomKey}_quick";
            byte[]? saveStateData = await PersistenceService.LoadSaveStateAsync(slotKey);
            
            if (saveStateData == null)
            {
                ShowSaveStateMessage("No save state found", false);
                return;
            }

            Emulator.DeserializeSaveState(saveStateData);
            ShowSaveStateMessage($"State loaded ({saveStateData.Length} bytes)", true);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load state error: {ex.Message}");
            ShowSaveStateMessage($"Error: {ex.Message}", false);
        }
    }

    private void ShowSaveStateMessage(string message, bool success)
    {
        _saveStateMessage = message;
        _saveStateSuccess = success;
        StateHasChanged();

        // Clear message after 3 seconds
        _ = Task.Delay(3000).ContinueWith(t =>
        {
            if (_saveStateMessage == message) // Only clear if it's still the same message
            {
                _saveStateMessage = null;
                InvokeAsync(StateHasChanged);
            }
        });
    }

    // Debug functionality (preserved from original)
    private async Task CreateTestPattern()
    {
        _isInTestMode = true; // Pause emulation
        Emulator.CreateTestPattern();
        // Immediately update the canvas to show the test pattern
        await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
    }

    private async Task CreateDirectTestPattern()
    {
        _isInTestMode = true; // Pause emulation
        Emulator.CreateDirectTestPattern();
        // Immediately update the canvas to show the test pattern
        await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
    }

    private void ShowDebugInfo()
    {
        _debugInfo = Emulator.GetDebugInfo();
        _showDebugInfo = !_showDebugInfo;
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
        
        // Save battery RAM before disposing
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = Emulator.GetBatteryRam();
                // Note: This is sync because Dispose can't be async
                // The data will be saved on next visit if this fails
                _ = Task.Run(async () => await PersistenceService.SaveBatteryRamAsync(_currentRomKey, batteryData));
            }
            catch
            {
                // Ignore errors during dispose
            }
        }
    }
}