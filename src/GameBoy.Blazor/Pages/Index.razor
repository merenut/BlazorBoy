@page "/"
@using GameBoy.Core
@using GameBoy.Core.Persistence
@using GameBoy.Blazor.Services
@using GameBoy.Blazor.Components
@inject Emulator Emulator
@inject IPersistenceService PersistenceService
@inject ISettingsService SettingsService
@inject IJSRuntime JS
@inject NavigationManager Navigation
@implements IDisposable

<!-- Header -->
<div class="game-header">
    <h1>BlazorBoy</h1>
</div>

<!-- Main Game Layout -->
<div class="game-layout-centered">
    <!-- Compact Game Cartridge Section -->
    <div class="game-cartridge-compact">
        <h6>Game Cartridge</h6>
        <RomLoader OnRomLoaded="OnRomLoaded" @ref="_romLoader" />
    </div>

    <!-- Basic Controls -->
    <div class="basic-controls">
        <EmulatorControls HasRom="_hasRom" 
                        IsRunning="_isRunning"
                        OnToggleRunPause="ToggleRunPause"
                        OnReset="ResetEmulator"
                        OnSpeedChangeCallback="OnSpeedChanged" 
                        @ref="_emulatorControls" />
    </div>

    <!-- Game Screen - Primary Focus -->
        <div class="game-screen-container">
            <div class="game-canvas-wrapper" tabindex="0" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" @onclick="OnCanvasClick" @ref="_focusable">
                <canvas id="screen" width="160" height="144" 
                        class="game-canvas"
                        style="width: 320px; height: 288px;"></canvas>
            </div>
            <div class="canvas-instruction">
                <small>Click on screen and use keyboard or touch controls</small>
            </div>
        </div>

    <!-- Save States -->
    <div class="save-states-compact">
        <h6>Save States</h6>
            <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <button class="btn-modern btn-success" @onclick="SaveState" disabled="@(!_hasRom)">
                    üíæ Quick Save
                </button>
                <button class="btn-modern btn-primary" @onclick="LoadState" disabled="@(!_hasRom)">
                    üìÅ Quick Load
                </button>
                @if (_saveStateMessage != null)
                {
                    <small style="color: @(_saveStateSuccess ? "var(--success)" : "var(--danger)")">@_saveStateMessage</small>
                }
        </div>
    </div>
</div>

<!-- Settings Overlay Toggle Button -->
<button class="overlay-toggle-btn" @onclick="ToggleSettingsOverlay" aria-label="Toggle Settings">
    ‚öôÔ∏è Settings
</button>

<!-- Settings Overlay -->
<div class="settings-overlay @(_showSettingsOverlay ? "show" : "")">
    <div class="overlay-header">
        <h6>Settings & Controls</h6>
        <button class="overlay-close" @onclick="ToggleSettingsOverlay" aria-label="Close Settings">√ó</button>
    </div>
    
    <div class="overlay-content">
        <!-- Audio Controls -->
        <div class="overlay-section">
            <h6>Audio</h6>
            <AudioToggle OnAudioStateChanged="OnAudioStateChanged"
                       OnVolumeChangeCallback="OnVolumeChanged" 
                       @ref="_audioToggle" />
        </div>

        <!-- Performance -->
        <div class="overlay-section">
            <h6>Performance</h6>
            <FpsCounter CurrentFps="_lastFps" @ref="_fpsCounter" />
        </div>

        <!-- Input Remapping -->
        <div class="overlay-section">
            <InputRemapping OnMappingsChanged="OnInputMappingsChanged" @ref="_inputRemapping" />
        </div>

        <!-- Debug Tools -->
        <div class="overlay-section">
            <h6>Debug Tools</h6>
            <div style="display: flex; flex-wrap: wrap; gap: 0.75rem;">
                <button class="btn-modern" @onclick="CreateTestPattern">Test VRAM</button>
                <button class="btn-modern" @onclick="CreateDirectTestPattern">Test Direct</button>
                <button class="btn-modern btn-info" @onclick="ShowDebugInfo">Debug Info</button>
                <button class="btn-modern btn-primary" @onclick="NavigateToDebugPage">üîß Debug Page</button>
            </div>
            
            @if (_showDebugInfo)
            {
                <div class="debug-panel">@_debugInfo</div>
            }
        </div>
    </div>
</div>

<!-- Touch Overlay for Mobile -->
<TouchOverlay OnButtonStateChanged="OnTouchInput" @ref="_touchOverlay" />

@code {
    // Component references
    private RomLoader? _romLoader;
    private EmulatorControls? _emulatorControls;
    private AudioToggle? _audioToggle;
    private FpsCounter? _fpsCounter;
    private InputRemapping? _inputRemapping;
    private TouchOverlay? _touchOverlay;

    // Core emulator state
    private DotNetObjectReference<Index>? _dotNetRef;
    private ElementReference _focusable;
    private bool _hasRom = false;
    private bool _isRunning = false;
    private bool _isInTestMode = false;
    private double _speedMultiplier = 1.0;
    private Dictionary<string, string> _inputMappings = new();

    // FPS tracking
    private double _lastFps;
    private long _lastTs;

    // Debug
    private bool _showDebugInfo = false;
    private string _debugInfo = "";

    // Settings overlay
    private bool _showSettingsOverlay = false;

    // Save state
    private string? _currentRomKey;
    private string? _saveStateMessage;
    private bool _saveStateSuccess;

    protected override async Task OnInitializedAsync()
    {
        // Load settings
        _speedMultiplier = await SettingsService.GetSpeedMultiplierAsync();
        _inputMappings = await SettingsService.GetInputMappingsAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            
            // Draw initial frame to ensure canvas shows default background color
            await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
            
            await JS.InvokeVoidAsync("gbInterop.startRenderLoop", _dotNetRef);
            await _focusable.FocusAsync();
        }
    }

    [JSInvokable]
    public async Task<bool> OnAnimationFrame(double timestamp)
    {
        if (_lastTs == 0)
            _lastTs = (long)timestamp;
        var delta = timestamp - _lastTs;
        _lastTs = (long)timestamp;
        if (delta > 0)
            _lastFps = 1000.0 / delta;

        // Skip emulation if we're in test mode or paused
        if (!_isInTestMode && _isRunning && _hasRom)
        {
            // Apply speed multiplier
            int cyclesPerFrame = (int)(17500 * _speedMultiplier); // Adjusted for speed
            bool frameReady = Emulator.StepFrame(cyclesPerFrame);
            
            if (frameReady)
            {
                await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
            }

            // Update audio if enabled
            await UpdateAudioBuffer();
        }
        
        StateHasChanged();
        return true; // continue loop
    }

    private async Task UpdateAudioBuffer()
    {
        try
        {
            var samples = Emulator.Apu.PullSamples();
            if (samples.Length > 0)
            {
                await JS.InvokeVoidAsync("gbInterop.updateAudioBuffer", samples);
            }
        }
        catch (JSException)
        {
            // Audio might not be initialized yet - this is normal
        }
    }

    // ROM loading
    private async Task OnRomLoaded((byte[] data, string fileName) romData)
    {
        // Save current battery RAM before loading new ROM
        await SaveCurrentBatteryRam();
        
        // Generate ROM key for persistence
        _currentRomKey = BatteryStore.GenerateRomKey(romData.data);
        
        // Load new ROM
        Emulator.LoadRom(romData.data);
        
        // Load battery RAM for this ROM if it exists
        await LoadBatteryRamForCurrentRom();
        
        _hasRom = true;
        _isRunning = true; // Auto-start when ROM loads
        _isInTestMode = false;
        
        StateHasChanged();
    }

    // Emulator control
    private void ToggleRunPause()
    {
        _isRunning = !_isRunning;
    }

    private void ResetEmulator()
    {
        if (_hasRom)
        {
            Emulator.Reset();
            _isRunning = true;
        }
    }

    private async Task OnSpeedChanged(double speed)
    {
        _speedMultiplier = speed;
        await SettingsService.SetSpeedMultiplierAsync(speed);
    }

    // Audio control
    private void OnAudioStateChanged(bool enabled)
    {
        // Audio state is managed by the AudioToggle component
    }

    private void OnVolumeChanged(double volume)
    {
        // Volume is managed by the AudioToggle component
    }

    // Input handling
    private void OnKeyDown(KeyboardEventArgs e) => UpdateJoypad(e, true);
    private void OnKeyUp(KeyboardEventArgs e) => UpdateJoypad(e, false);

    private void UpdateJoypad(KeyboardEventArgs e, bool down)
    {
        // Use current input mappings
        foreach (var mapping in _inputMappings)
        {
            if (mapping.Value == e.Key)
            {
                switch (mapping.Key)
                {
                    case "Up": Emulator.Joypad.Up = down; break;
                    case "Down": Emulator.Joypad.Down = down; break;
                    case "Left": Emulator.Joypad.Left = down; break;
                    case "Right": Emulator.Joypad.Right = down; break;
                    case "A": Emulator.Joypad.A = down; break;
                    case "B": Emulator.Joypad.B = down; break;
                    case "Start": Emulator.Joypad.Start = down; break;
                    case "Select": Emulator.Joypad.Select = down; break;
                }
                break;
            }
        }
    }

    private void OnTouchInput((string button, bool pressed) input)
    {
        // Handle touch input
        switch (input.button)
        {
            case "Up": Emulator.Joypad.Up = input.pressed; break;
            case "Down": Emulator.Joypad.Down = input.pressed; break;
            case "Left": Emulator.Joypad.Left = input.pressed; break;
            case "Right": Emulator.Joypad.Right = input.pressed; break;
            case "A": Emulator.Joypad.A = input.pressed; break;
            case "B": Emulator.Joypad.B = input.pressed; break;
            case "Start": Emulator.Joypad.Start = input.pressed; break;
            case "Select": Emulator.Joypad.Select = input.pressed; break;
        }
    }

    private async Task OnInputMappingsChanged(Dictionary<string, string> mappings)
    {
        _inputMappings = mappings;
        await SettingsService.SetInputMappingsAsync(mappings);
    }

    private void OnCanvasClick()
    {
        _isInTestMode = false; // Resume emulation when user clicks canvas
    }

    // Save state functionality (preserved from original)
    private async Task SaveCurrentBatteryRam()
    {
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = Emulator.GetBatteryRam();
                await PersistenceService.SaveBatteryRamAsync(_currentRomKey, batteryData);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to save battery RAM: {ex.Message}");
            }
        }
    }

    private async Task LoadBatteryRamForCurrentRom()
    {
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = await PersistenceService.LoadBatteryRamAsync(_currentRomKey);
                if (batteryData != null)
                {
                    Emulator.LoadBatteryRam(batteryData);
                    Console.WriteLine($"Loaded battery RAM for {_currentRomKey} ({batteryData.Length} bytes)");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load battery RAM: {ex.Message}");
            }
        }
    }

    private async Task SaveState()
    {
        if (_currentRomKey == null)
        {
            ShowSaveStateMessage("No ROM loaded", false);
            return;
        }

        try
        {
            byte[] saveStateData = Emulator.SerializeSaveState();
            string slotKey = $"{_currentRomKey}_quick";
            
            bool success = await PersistenceService.SaveSaveStateAsync(slotKey, saveStateData);
            if (success)
            {
                ShowSaveStateMessage($"State saved ({saveStateData.Length} bytes)", true);
            }
            else
            {
                ShowSaveStateMessage("Failed to save state", false);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Save state error: {ex.Message}");
            ShowSaveStateMessage($"Error: {ex.Message}", false);
        }
    }

    private async Task LoadState()
    {
        if (_currentRomKey == null)
        {
            ShowSaveStateMessage("No ROM loaded", false);
            return;
        }

        try
        {
            string slotKey = $"{_currentRomKey}_quick";
            byte[]? saveStateData = await PersistenceService.LoadSaveStateAsync(slotKey);
            
            if (saveStateData == null)
            {
                ShowSaveStateMessage("No save state found", false);
                return;
            }

            Emulator.DeserializeSaveState(saveStateData);
            ShowSaveStateMessage($"State loaded ({saveStateData.Length} bytes)", true);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load state error: {ex.Message}");
            ShowSaveStateMessage($"Error: {ex.Message}", false);
        }
    }

    private void ShowSaveStateMessage(string message, bool success)
    {
        _saveStateMessage = message;
        _saveStateSuccess = success;
        StateHasChanged();

        // Clear message after 3 seconds
        _ = Task.Delay(3000).ContinueWith(t =>
        {
            if (_saveStateMessage == message) // Only clear if it's still the same message
            {
                _saveStateMessage = null;
                InvokeAsync(StateHasChanged);
            }
        });
    }

    // Debug functionality (preserved from original)
    private async Task CreateTestPattern()
    {
        _isInTestMode = true; // Pause emulation
        Emulator.CreateTestPattern();
        // Immediately update the canvas to show the test pattern
        await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
    }

    private async Task CreateDirectTestPattern()
    {
        _isInTestMode = true; // Pause emulation
        Emulator.CreateDirectTestPattern();
        // Immediately update the canvas to show the test pattern
        await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
    }

    private void ShowDebugInfo()
    {
        _debugInfo = Emulator.GetDebugInfo();
        _showDebugInfo = !_showDebugInfo;
    }

    private void NavigateToDebugPage()
    {
        Navigation.NavigateTo("/debug");
    }

    private void ToggleSettingsOverlay()
    {
        _showSettingsOverlay = !_showSettingsOverlay;
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
        
        // Save battery RAM before disposing
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = Emulator.GetBatteryRam();
                // Note: This is sync because Dispose can't be async
                // The data will be saved on next visit if this fails
                _ = Task.Run(async () => await PersistenceService.SaveBatteryRamAsync(_currentRomKey, batteryData));
            }
            catch
            {
                // Ignore errors during dispose
            }
        }
    }
}