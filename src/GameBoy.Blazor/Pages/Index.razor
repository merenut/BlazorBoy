@page "/"
@using GameBoy.Core
@using GameBoy.Core.Persistence
@using GameBoy.Blazor.Services
@using GameBoy.Blazor.Components
@using System.IO
@inject Emulator Emulator
@inject IPersistenceService PersistenceService
@inject ISettingsService SettingsService
@inject IJSRuntime JS
@inject NavigationManager Navigation
@implements IDisposable

<!-- Header -->
<div class="game-header">
    <h1>BlazorBoy</h1>
</div>

<!-- Main Game Layout -->
<div class="game-layout-centered">
    <!-- Compact Game Cartridge Section -->
    <div class="game-cartridge-compact">
        <h6>Game Cartridge</h6>
        <RomLoader OnRomLoaded="OnRomLoaded" @ref="_romLoader" />
    </div>



    <!-- Game Screen - Primary Focus -->
        <div class="game-screen-container">
            <div class="game-canvas-wrapper" tabindex="0" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" @onclick="OnCanvasClick" @ref="_focusable">
                <canvas id="screen" width="160" height="144" 
                        class="game-canvas"
                        style="width: 320px; height: 288px;"></canvas>
            </div>
            <div class="canvas-instruction">
                <small>Click on screen and use keyboard or touch controls</small>
            </div>
        </div>

    <!-- Save States -->
    <div class="save-states-compact">
        <h6>Save States</h6>
            <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <button class="btn-modern btn-success" @onclick="SaveState" disabled="@(!_hasRom)">
                    üíæ Quick Save
                </button>
                <button class="btn-modern btn-primary" @onclick="LoadState" disabled="@(!_hasRom)">
                    üìÅ Quick Load
                </button>
                @if (_saveStateMessage != null)
                {
                    <small style="color: @(_saveStateSuccess ? "var(--success)" : "var(--danger)")">@_saveStateMessage</small>
                }
        </div>
    </div>
</div>

<!-- Settings Overlay Toggle Button -->
<button class="overlay-toggle-btn" @onclick="ToggleSettingsOverlay" aria-label="Toggle Settings">
    ‚öôÔ∏è Settings
</button>

<!-- Settings Overlay -->
<div class="settings-overlay @(_showSettingsOverlay ? "show" : "")">
    <div class="overlay-header">
        <h6>Settings & Controls</h6>
        <button class="overlay-close" @onclick="ToggleSettingsOverlay" aria-label="Close Settings">√ó</button>
    </div>
    
    <div class="overlay-content">
        <!-- Emulator Controls -->
        <div class="overlay-section">
            <h6>Emulator Controls</h6>
            <EmulatorControls HasRom="_hasRom" 
                            IsRunning="_isRunning"
                            OnToggleRunPause="ToggleRunPause"
                            OnReset="ResetEmulator"
                            OnSpeedChangeCallback="OnSpeedChanged" 
                            @ref="_emulatorControls" />
        </div>

        <!-- Audio Controls -->
        <div class="overlay-section">
            <h6>Audio</h6>
            <AudioToggle OnAudioStateChanged="OnAudioStateChanged"
                       OnVolumeChangeCallback="OnVolumeChanged" 
                       @ref="_audioToggle" />
        </div>

        <!-- Performance -->
        <div class="overlay-section">
            <h6>Performance</h6>
            <FpsCounter CurrentFps="_lastFps" @ref="_fpsCounter" />
        </div>

        <!-- Input Remapping -->
        <div class="overlay-section">
            <InputRemapping OnMappingsChanged="OnInputMappingsChanged" @ref="_inputRemapping" />
        </div>

        <!-- Debug Tools -->
        <div class="overlay-section">
            <h6>Debug Tools</h6>
            <div style="display: flex; flex-wrap: wrap; gap: 0.75rem;">
                <button class="btn-modern" @onclick="CreateTestPattern">Test VRAM</button>
                <button class="btn-modern" @onclick="CreateDirectTestPattern">Test Direct</button>
                <button class="btn-modern btn-warning" @onclick="LoadTetrisForTesting">üéÆ Load Test ROM</button>
                <button class="btn-modern btn-info" @onclick="ShowDebugInfo">Debug Info</button>
                <button class="btn-modern btn-primary" @onclick="NavigateToDebugPage">üîß Debug Page</button>
            </div>
            
            @if (_showDebugInfo)
            {
                <div class="debug-panel">@_debugInfo</div>
            }
        </div>
    </div>
</div>

<!-- Touch Overlay for Mobile -->
<TouchOverlay OnButtonStateChanged="OnTouchInput" @ref="_touchOverlay" />

@code {
    // Component references
    private RomLoader? _romLoader;
    private EmulatorControls? _emulatorControls;
    private AudioToggle? _audioToggle;
    private FpsCounter? _fpsCounter;
    private InputRemapping? _inputRemapping;
    private TouchOverlay? _touchOverlay;

    // Core emulator state
    private DotNetObjectReference<Index>? _dotNetRef;
    private ElementReference _focusable;
    private bool _hasRom = false;
    private bool _isRunning = false;
    private bool _isInTestMode = false;
    private double _speedMultiplier = 1.0;
    private Dictionary<string, string> _inputMappings = new();

    // FPS tracking
    private double _lastFps;
    private long _lastTs;
    
    // Enhanced adaptive performance system
    private int _currentCyclesPerFrame = 17500; // Start conservatively at 25% accuracy for WebAssembly
    private const int FullAccuracyCycles = 70224; // Full Game Boy accuracy
    private const int MinCyclesPerFrame = 12000; // ~17% accuracy for emergency performance mode
    private const double TargetFps = 35.0; // More realistic target for WebAssembly
    private const double FpsAdjustmentThreshold = 3.0; // Smaller threshold for faster response
    private const double EmergencyFpsThreshold = 15.0; // Emergency threshold for immediate scaling
    private int _performanceFrameCounter = 0;
    private const int PerformanceAdjustmentInterval = 10; // Adjust every 10 frames (~0.17 seconds) for faster response
    private double _recentFpsHistory = 0.0; // Track recent FPS for smoother adjustments

    // Debug
    private bool _showDebugInfo = false;
    private string _debugInfo = "";

    // Settings overlay
    private bool _showSettingsOverlay = false;

    // Save state
    private string? _currentRomKey;
    private string? _saveStateMessage;
    private bool _saveStateSuccess;
    
    // UI state for new design
    private bool _audioEnabled = true;
    private bool _fullscreenEnabled = false;
    private string _screenSize = "Standard";
    private string _filterPreset = "None";
    private string _selectedPalette = "classic";
    private bool _saveSlot1Used = false;
    private bool _saveSlot2Used = false;
    private bool _saveSlot3Used = false;

    protected override async Task OnInitializedAsync()
    {
        // Load settings
        _speedMultiplier = await SettingsService.GetSpeedMultiplierAsync();
        _inputMappings = await SettingsService.GetInputMappingsAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            
            // Draw initial frame to ensure canvas shows default background color
            await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
            
            await JS.InvokeVoidAsync("gbInterop.startRenderLoop", _dotNetRef);
            await _focusable.FocusAsync();
        }
    }

    [JSInvokable]
    public async Task<bool> OnAnimationFrame(double timestamp)
    {
        if (_lastTs == 0)
            _lastTs = (long)timestamp;
        var delta = timestamp - _lastTs;
        _lastTs = (long)timestamp;
        if (delta > 0)
            _lastFps = 1000.0 / delta;

        // Skip emulation if we're in test mode or paused
        if (!_isInTestMode && _isRunning && _hasRom)
        {
            // Adaptive performance adjustment
            _performanceFrameCounter++;
            if (_performanceFrameCounter >= PerformanceAdjustmentInterval)
            {
                AdjustPerformanceBasedOnFps();
                _performanceFrameCounter = 0;
            }
            
            // Apply speed multiplier with adaptive cycles
            int cyclesPerFrame = (int)(_currentCyclesPerFrame * _speedMultiplier);
            bool frameReady = Emulator.StepFrame(cyclesPerFrame);
            
            if (frameReady)
            {
                await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
            }

            // Update audio if enabled
            await UpdateAudioBuffer();
        }
        
        StateHasChanged();
        return true; // continue loop
    }

    private async Task UpdateAudioBuffer()
    {
        try
        {
            var samples = Emulator.Apu.PullSamples();
            if (samples.Length > 0)
            {
                await JS.InvokeVoidAsync("gbInterop.updateAudioBuffer", samples);
            }
        }
        catch (JSException)
        {
            // Audio might not be initialized yet - this is normal
        }
    }

    // ROM loading with adaptive performance initialization
    private async Task OnRomLoaded((byte[] data, string fileName) romData)
    {
        // Save current battery RAM before loading new ROM
        await SaveCurrentBatteryRam();
        
        // Generate ROM key for persistence
        _currentRomKey = BatteryStore.GenerateRomKey(romData.data);
        
        // Load new ROM
        Emulator.LoadRom(romData.data);
        
        // Load battery RAM for this ROM if it exists
        await LoadBatteryRamForCurrentRom();
        
        // Initialize adaptive performance based on ROM complexity
        InitializeAdaptivePerformanceForRom(romData.fileName);
        
        _hasRom = true;
        _isRunning = true; // Auto-start when ROM loads
        _isInTestMode = false;
        
        StateHasChanged();
    }
    
    /// <summary>
    /// Initialize performance settings based on ROM complexity
    /// </summary>
    private void InitializeAdaptivePerformanceForRom(string fileName)
    {
        // Reset performance tracking
        _performanceFrameCounter = 0;
        _recentFpsHistory = 0.0;
        
        // Detect complex ROMs that need conservative initial settings
        string lowerFileName = fileName.ToLowerInvariant();
        if (lowerFileName.Contains("tetris") || 
            lowerFileName.Contains("zelda") || 
            lowerFileName.Contains("mario") ||
            lowerFileName.Contains("pokemon"))
        {
            // Start very conservatively for complex ROMs
            _currentCyclesPerFrame = MinCyclesPerFrame;
            Console.WriteLine($"Complex ROM detected ({fileName}): Starting with minimum cycles {_currentCyclesPerFrame}");
        }
        else
        {
            // Standard starting point for simpler ROMs
            _currentCyclesPerFrame = 17500; // 25% accuracy
            Console.WriteLine($"Standard ROM loaded ({fileName}): Starting with {_currentCyclesPerFrame} cycles");
        }
    }

    // Emulator control
    private void ToggleRunPause()
    {
        _isRunning = !_isRunning;
    }

    private void ResetEmulator()
    {
        if (_hasRom)
        {
            Emulator.Reset();
            _isRunning = true;
        }
    }

    private async Task OnSpeedChanged(double speed)
    {
        _speedMultiplier = speed;
        await SettingsService.SetSpeedMultiplierAsync(speed);
    }

    /// <summary>
    /// Enhanced adaptive performance adjustment with aggressive WebAssembly optimization
    /// </summary>
    private void AdjustPerformanceBasedOnFps()
    {
        if (_lastFps <= 0) return; // No FPS data yet
        
        // Update FPS history for smoother adjustments
        _recentFpsHistory = _recentFpsHistory * 0.7 + _lastFps * 0.3;
        double workingFps = _recentFpsHistory > 0 ? _recentFpsHistory : _lastFps;
        
        // Emergency scaling for severe performance issues
        if (workingFps < EmergencyFpsThreshold && _currentCyclesPerFrame > MinCyclesPerFrame)
        {
            // Immediately drop to minimum for recovery
            _currentCyclesPerFrame = MinCyclesPerFrame;
            Console.WriteLine($"Emergency scaling: FPS {workingFps:F1} -> Cycles reduced to {_currentCyclesPerFrame}");
            return;
        }
        
        double fpsDifference = workingFps - TargetFps;
        
        // Aggressive performance mode - larger adjustments for poor performance
        if (fpsDifference < -FpsAdjustmentThreshold && _currentCyclesPerFrame > MinCyclesPerFrame)
        {
            // Scale reduction based on how far below target we are
            double severityFactor = Math.Max(1.0, Math.Abs(fpsDifference) / 10.0);
            int baseReduction = Math.Max(1500, _currentCyclesPerFrame / 8); // Larger base reduction
            int reduction = (int)(baseReduction * severityFactor);
            
            _currentCyclesPerFrame = Math.Max(MinCyclesPerFrame, _currentCyclesPerFrame - reduction);
            Console.WriteLine($"Performance mode: FPS {workingFps:F1} -> Cycles reduced by {reduction} to {_currentCyclesPerFrame}");
        }
        // Conservative accuracy mode - smaller increases for good performance
        else if (fpsDifference > FpsAdjustmentThreshold && _currentCyclesPerFrame < FullAccuracyCycles)
        {
            // Only increase if we're well above target with sustained good performance
            if (workingFps > TargetFps + 8.0) // Require 8+ FPS above target for increases
            {
                int increase = Math.Max(800, _currentCyclesPerFrame / 15); // Smaller, careful increases
                _currentCyclesPerFrame = Math.Min(FullAccuracyCycles, _currentCyclesPerFrame + increase);
                Console.WriteLine($"Accuracy mode: FPS {workingFps:F1} -> Cycles increased by {increase} to {_currentCyclesPerFrame}");
            }
        }
        
        // Cap cycles based on sustained performance
        double accuracyPercent = (_currentCyclesPerFrame / (double)FullAccuracyCycles) * 100;
        Console.WriteLine($"Adaptive performance: {accuracyPercent:F1}% accuracy, {workingFps:F1} FPS");
    }

    // Audio control
    private void OnAudioStateChanged(bool enabled)
    {
        // Audio state is managed by the AudioToggle component
    }

    private void OnVolumeChanged(double volume)
    {
        // Volume is managed by the AudioToggle component
    }

    // Input handling
    private void OnKeyDown(KeyboardEventArgs e) => UpdateJoypad(e, true);
    private void OnKeyUp(KeyboardEventArgs e) => UpdateJoypad(e, false);

    private void UpdateJoypad(KeyboardEventArgs e, bool down)
    {
        // Use current input mappings
        foreach (var mapping in _inputMappings)
        {
            if (mapping.Value == e.Key)
            {
                switch (mapping.Key)
                {
                    case "Up": Emulator.Joypad.Up = down; break;
                    case "Down": Emulator.Joypad.Down = down; break;
                    case "Left": Emulator.Joypad.Left = down; break;
                    case "Right": Emulator.Joypad.Right = down; break;
                    case "A": Emulator.Joypad.A = down; break;
                    case "B": Emulator.Joypad.B = down; break;
                    case "Start": Emulator.Joypad.Start = down; break;
                    case "Select": Emulator.Joypad.Select = down; break;
                }
                break;
            }
        }
    }

    private void OnTouchInput((string button, bool pressed) input)
    {
        // Handle touch input
        switch (input.button)
        {
            case "Up": Emulator.Joypad.Up = input.pressed; break;
            case "Down": Emulator.Joypad.Down = input.pressed; break;
            case "Left": Emulator.Joypad.Left = input.pressed; break;
            case "Right": Emulator.Joypad.Right = input.pressed; break;
            case "A": Emulator.Joypad.A = input.pressed; break;
            case "B": Emulator.Joypad.B = input.pressed; break;
            case "Start": Emulator.Joypad.Start = input.pressed; break;
            case "Select": Emulator.Joypad.Select = input.pressed; break;
        }
    }

    private async Task OnInputMappingsChanged(Dictionary<string, string> mappings)
    {
        _inputMappings = mappings;
        await SettingsService.SetInputMappingsAsync(mappings);
    }

    private void OnCanvasClick()
    {
        _isInTestMode = false; // Resume emulation when user clicks canvas
    }

    // Save state functionality (preserved from original)
    private async Task SaveCurrentBatteryRam()
    {
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = Emulator.GetBatteryRam();
                await PersistenceService.SaveBatteryRamAsync(_currentRomKey, batteryData);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to save battery RAM: {ex.Message}");
            }
        }
    }

    private async Task LoadBatteryRamForCurrentRom()
    {
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = await PersistenceService.LoadBatteryRamAsync(_currentRomKey);
                if (batteryData != null)
                {
                    Emulator.LoadBatteryRam(batteryData);
                    Console.WriteLine($"Loaded battery RAM for {_currentRomKey} ({batteryData.Length} bytes)");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load battery RAM: {ex.Message}");
            }
        }
    }

    private async Task SaveState()
    {
        if (_currentRomKey == null)
        {
            ShowSaveStateMessage("No ROM loaded", false);
            return;
        }

        try
        {
            byte[] saveStateData = Emulator.SerializeSaveState();
            string slotKey = $"{_currentRomKey}_quick";
            
            bool success = await PersistenceService.SaveSaveStateAsync(slotKey, saveStateData);
            if (success)
            {
                ShowSaveStateMessage($"State saved ({saveStateData.Length} bytes)", true);
            }
            else
            {
                ShowSaveStateMessage("Failed to save state", false);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Save state error: {ex.Message}");
            ShowSaveStateMessage($"Error: {ex.Message}", false);
        }
    }

    private async Task LoadState()
    {
        if (_currentRomKey == null)
        {
            ShowSaveStateMessage("No ROM loaded", false);
            return;
        }

        try
        {
            string slotKey = $"{_currentRomKey}_quick";
            byte[]? saveStateData = await PersistenceService.LoadSaveStateAsync(slotKey);
            
            if (saveStateData == null)
            {
                ShowSaveStateMessage("No save state found", false);
                return;
            }

            Emulator.DeserializeSaveState(saveStateData);
            ShowSaveStateMessage($"State loaded ({saveStateData.Length} bytes)", true);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load state error: {ex.Message}");
            ShowSaveStateMessage($"Error: {ex.Message}", false);
        }
    }

    private void ShowSaveStateMessage(string message, bool success)
    {
        _saveStateMessage = message;
        _saveStateSuccess = success;
        StateHasChanged();

        // Clear message after 3 seconds
        _ = Task.Delay(3000).ContinueWith(t =>
        {
            if (_saveStateMessage == message) // Only clear if it's still the same message
            {
                _saveStateMessage = null;
                InvokeAsync(StateHasChanged);
            }
        });
    }

    // Debug functionality with Tetris loading for testing
    private async Task LoadTetrisForTesting()
    {
        try
        {
            // For testing purposes, create a simulation of Tetris performance
            // since direct file access isn't available in WebAssembly
            Console.WriteLine("Loading performance test simulation...");
            
            // Create a minimal test ROM that will exercise the emulator
            byte[] testRom = CreatePerformanceTestRom();
            await OnRomLoaded((testRom, "PerformanceTest.gb"));
            Console.WriteLine("Performance test ROM loaded - simulating complex game behavior");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load performance test: {ex.Message}");
        }
    }
    
    /// <summary>
    /// Creates a minimal ROM that exercises the emulator for performance testing
    /// </summary>
    private byte[] CreatePerformanceTestRom()
    {
        // Create a minimal 32KB ROM with header and some basic instructions
        byte[] rom = new byte[32768];
        
        // ROM header (at 0x100-0x14F)
        rom[0x0143] = 0x00; // CGB flag - DMG only
        rom[0x0147] = 0x00; // MBC type - ROM only
        rom[0x0148] = 0x00; // ROM size - 32KB
        rom[0x0149] = 0x00; // RAM size - none
        
        // Calculate header checksum
        int checksum = 0;
        for (int i = 0x0134; i < 0x014D; i++)
        {
            checksum = checksum - rom[i] - 1;
        }
        rom[0x014D] = (byte)(checksum & 0xFF);
        
        // Entry point (0x0100) - jump to main code
        rom[0x0100] = 0xC3; // JP instruction
        rom[0x0101] = 0x50; // Low byte of address 0x0150
        rom[0x0102] = 0x01; // High byte of address 0x0150
        
        // Main code loop (0x0150+) - create a busy loop that exercises CPU
        int addr = 0x0150;
        rom[addr++] = 0x21; // LD HL, 0x9800 (VRAM)
        rom[addr++] = 0x00;
        rom[addr++] = 0x98;
        
        rom[addr++] = 0x06; // LD B, 0xFF
        rom[addr++] = 0xFF;
        
        // Loop start
        rom[addr++] = 0x36; // LD (HL), value
        rom[addr++] = 0xAA;
        rom[addr++] = 0x23; // INC HL
        rom[addr++] = 0x05; // DEC B
        rom[addr++] = 0x20; // JR NZ, -4
        rom[addr++] = 0xFC;
        
        rom[addr++] = 0x18; // JR -10 (infinite loop)
        rom[addr++] = 0xF6;
        
        return rom;
    }
    
    private async Task CreateTestPattern()
    {
        _isInTestMode = true; // Pause emulation
        Emulator.CreateTestPattern();
        // Immediately update the canvas to show the test pattern
        await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
    }

    private async Task CreateDirectTestPattern()
    {
        _isInTestMode = true; // Pause emulation
        Emulator.CreateDirectTestPattern();
        // Immediately update the canvas to show the test pattern
        await JS.InvokeVoidAsync("gbInterop.drawFrameRgba", "screen", Ppu.ScreenWidth, Ppu.ScreenHeight, Emulator.Ppu.FrameBufferRgba);
    }

    private void ShowDebugInfo()
    {
        _debugInfo = Emulator.GetDebugInfo();
        _showDebugInfo = !_showDebugInfo;
    }

    private void NavigateToDebugPage()
    {
        Navigation.NavigateTo("/debug");
    }

    private void ToggleSettingsOverlay()
    {
        _showSettingsOverlay = !_showSettingsOverlay;
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
        
        // Save battery RAM before disposing
        if (_currentRomKey != null && Emulator.HasBatteryRam)
        {
            try
            {
                byte[]? batteryData = Emulator.GetBatteryRam();
                // Note: This is sync because Dispose can't be async
                // The data will be saved on next visit if this fails
                _ = Task.Run(async () => await PersistenceService.SaveBatteryRamAsync(_currentRomKey, batteryData));
            }
            catch
            {
                // Ignore errors during dispose
            }
        }
    }
}