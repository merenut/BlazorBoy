# BlazorBoy – End-to-End Development Plan

Author: (Generated by Copilot Space)  
Target: Build a Game Boy (DMG) emulator with a Blazor WebAssembly frontend using the current repository scaffold.  
Status: Phase 1 partially implemented (MMU map + post-BIOS defaults + frame loop). See 3.1 for current status and remaining work.

---

## Table of Contents
1. High-Level Phases
2. Repository & Structure
3. Phase Details  
   3.1 Core Foundations  
   3.2 Cartridge & MBCs  
   3.3 CPU Core  
   3.4 Interrupts  
   3.5 Timers  
   3.6 PPU Pipeline  
   3.7 DMA  
   3.8 Joypad  
   3.9 Serial (Stub)  
   3.10 APU (Audio)  
   3.11 Persistence (Battery / Save States)  
   3.12 Debug Tooling  
   3.13 Blazor Frontend Integration  
   3.14 Automated Testing  
   3.15 Performance & Optimization  
   3.16 Packaging & CI/CD
4. Test ROM Strategy
5. Milestones
6. Immediate Next Steps
7. Risk & Mitigation
8. Appendix (Code Snippets)

---

## 1. High-Level Phases

0. Scaffold & Baseline  
1. MMU & Core Constants  
2. Cartridge & MBCs  
3. CPU (Fetch/Decode/Execute)  
4. Interrupt Controller  
5. Timers (DIV/TIMA/TMA/TAC)  
6. PPU (Modes, BG, Window, Sprites)  
7. DMA (OAM DMA)  
8. Joypad Matrix  
9. Serial Stub  
10. APU (Channels 1–4)  
11. Persistence (Battery RAM, Save States)  
12. Debugging / Introspection  
13. Blazor Integration Enhancements  
14. Test Harness & ROM Automation  
15. Performance Optimization  
16. Packaging / Docs / CI

---

## 2. Repository & Structure

Current (simplified):
```
src/
  GameBoy.Core/
    Cpu.cs
    Mmu.cs
    Cartridge.cs
    Mbc0.cs
    InterruptController.cs
    Ppu.cs
    Timer.cs
    Emulator.cs
  GameBoy.Blazor/
    Pages/Index.razor
    wwwroot/js/emulator.js (expected, referenced)
tests/
  GameBoy.Tests/ (to create)
```

Planned Additions (core-focused):
```
GameBoy.Core/
  Cart/
    CartridgeHeader.cs
    Mbc1.cs
    Mbc3.cs
    Mbc5.cs
  Cpu/
    OpcodeTable.cs
    Instruction.cs
    Alu.cs
    Disassembler.cs
  Interrupts/
    InterruptController.cs (expanded)
  Ppu/
    Lcdc.cs
    Sprite.cs
    Palette.cs
    Fetcher.cs (optional)
  Apu/
    Apu.cs
    Square1.cs
    Square2.cs
    Wave.cs
    Noise.cs
  Persistence/
    BatteryStore.cs
    SaveStateSerializer.cs
  Debug/
    BreakpointManager.cs
    TraceLogger.cs
```

---

## 3. Phase Details

### 3.1 Phase 1: Core Foundations (MMU & Boot State)

Files:
- Mmu.cs (expand I/O mapping stubs)
- IoRegisters (static class of consts) – optional
- BootRom.cs (optional; skip and emulate post-BIOS state)
- Emulator.cs (frame orchestration later)

Key Methods:
- Mmu.ReadByte / WriteByte (add word helpers)
- Handle echo RAM mirroring (E000–FDFF → C000–DDFF)
- Reserve areas: unusable 0xFEA0–0xFEFF
- Add stub I/O register handling (FF00, FF04–07, FF0F, FF40–FF4B, FF46, FF47–49, FF4D reserved later)

Dependencies:
- Cartridge for ROM reads
- Future: Timer/PPU/InterruptController for I/O

Testing:
- Unit tests for memory regions, echo, and restricted zones.

Current implementation status (as of 2025-09-07):
- Implemented
  - Echo RAM mirroring E000–FDFF → C000–DDFF (Mmu.ReadByte/WriteByte).
  - Unusable region 0xFEA0–0xFEFF returns 0xFF; writes ignored.
  - Post-BIOS defaults initialized (InitializePostBiosDefaults) and backing fields exist for key I/O registers.
  - Word helpers ReadWord/WriteWord implemented.
  - ROM access via Cartridge.ReadRom and Cartridge.Detect (MBC0 only).
  - Emulator frame loop accumulates cycles toward 70224 per frame (Emulator.StepFrame).

- Needs fixes/remaining to complete Phase 1
  - I/O region wiring:
    - ReadByte currently returns 0xFF for 0xFF00–0xFF7F. It should call ReadIoRegister to return stubbed values (e.g., JOYP lower nibble reads 1s, IF upper bits forced to 1).
    - WriteByte currently latches to _mem for 0xFF00–0xFF7F. It should call WriteIoRegister to enforce behavior (e.g., DIV write clears to 0).
  - Constants bug:
    - Mmu.IoStart and InterruptEnable reference IoRegs (e.g., IoRegs.P1_JOYP, IoRegs.IE), but IoRegs does not exist. Either:
      - Replace with literal constants (IoStart = 0xFF00, InterruptEnable = 0xFFFF), or
      - Add a new static class IoRegs with P1_JOYP = 0xFF00 and IE = 0xFFFF (preferred for clarity).
  - IE/IF defaults are set, but IF/IE should be consistently exposed via ReadIoRegister/WriteIoRegister to match stub behavior (IF upper three bits read as 1; IE is at 0xFFFF outside I/O region).
  - InitializePostBiosDefaults currently writes to _mem; since I/O reads should come from ReadIoRegister, ensure backing fields mirror these defaults (they already do) and wire the read/write paths as above.
  - Tests: no unit tests yet for memory map, echo, unusable area, and I/O stubs.

Checklist to close Phase 1:
- [ ] Add IoRegs class or correct Mmu.IoStart/InterruptEnable constants.
- [ ] Route I/O reads to ReadIoRegister in Mmu.ReadByte.
- [ ] Route I/O writes to WriteIoRegister in Mmu.WriteByte.
- [ ] Verify IF (0xFF0F) and IE (0xFFFF) read/write semantics match stub masks noted in code.
- [ ] Add minimal unit tests:
  - [ ] Echo mirroring (E000–FDFF mirrors C000–DDFF)
  - [ ] Unusable region returns 0xFF and ignores writes
  - [ ] JOYP lower nibble read as 1s; DIV write clears; IF upper bits read as 1s
  - [ ] IE at 0xFFFF read/write round-trips

### 3.2 Phase 2: Cartridge & MBCs
Files:
- Cartridge.cs (expand Detect logic)
- CartridgeHeader.cs (parse metadata at 0x0100–0x014F)
- Mbc1.cs, Mbc3.cs, Mbc5.cs (prioritize these)
- Interface: `IBatteryBacked`

Key Methods:
- Bank switching: ROM and external RAM
- MBC1: ROM bank low 5 bits, RAM enable, mode switch
- MBC3: RTC stub (defer full)
- MBC5: 9-bit ROM bank, large RAM layout
- Cartridge.Detect: instantiate correct subclass based on type byte
- Load/Save External RAM

Testing:
- Unit: synthetic ROM arrays with known bank markers
- Integration: simple test ROM that reads from switched banks

### 3.3 Phase 3: CPU Core Implementation
Files:
- Cpu.cs (replace placeholder)
- OpcodeTable.cs
- Instruction.cs (struct { string Mnemonic; int Length; int BaseCycles; Func<Cpu,int> Execute; })
- Alu.cs (flag helpers)
- Disassembler.cs

Key Methods:
- Cpu.Step(): fetch, decode, execute, return cycles
- Implement instruction groups incrementally:
  1. NOP/LD immediate/register loads
  2. INC/DEC/16-bit ops
  3. ALU (ADD/ADC/SUB/SBC/AND/OR/XOR/CP)
  4. Rotates/Shifts + CB prefix
  5. BIT/RES/SET
  6. Control flow (JR, JP, CALL, RET, RST)
  7. Misc (DAA, CPL, SCF, CCF, HALT/STOP, EI/DI)

Dependencies:
- MMU
- InterruptController (Enable/Disable logic; IME delay after EI)

Testing:
- Blargg cpu_instrs (core)
- Unit: DAA edge cases, flag correctness
- Regression: hash of registers at checkpoints

### 3.4 Phase 4: Interrupt Controller
Files:
- InterruptController.cs (expand with IF/IE representation)
- Enum InterruptType { VBlank, LCDStat, Timer, Serial, Joypad }

Key Methods:
- Request(InterruptType)
- Service(Cpu) (push PC, jump vector, clear IF bit)
- Memory mapping: IF @0xFF0F, IE @0xFFFF

Dependencies:
- CPU calls Check after each instruction
- PPU, Timer, Joypad trigger requests

Testing:
- Synthetic: raise multiple interrupts, assert priority order
- Integration: Blargg interrupt test

### 3.5 Phase 5: Timers
Files:
- Timer.cs (add internal counters)
- Integrate with Mmu for FF04–FF07

Key Methods:
- Step(cycles)
- DIV increments at 16384 Hz
- TIMA increments at selected frequency (TAC lower bits)
- Overflow: set TIMA = TMA, request Timer interrupt (simulate timing subtly later)

Testing:
- Blargg timer test
- Unit: frequency mapping table correctness

### 3.6 Phase 6: PPU Pipeline
Files:
- Ppu.cs (full state machine)
- Lcdc.cs (bit decode for LCDC)
- Sprite.cs (OAM entry)
- Palette.cs
- Optional: Pixel FIFO, Fetcher.cs
- Constants for mode durations

Key Methods:
- Step(cycles): manage modes 0–3 + VBlank
- Render background per scanline
- Window layer
- OAM scan (10 sprite limit per line)
- Compositing order (OBJ priority & palette)
- Expose FrameBuffer (int[] RGBA)

Dependencies:
- Mmu for VRAM/OAM/Registers
- InterruptController for VBlank & STAT

Testing:
- Mooneye: lcd_sync, sprite_priority
- Visual: dmg-acid2 (goal image)
- Frame hash after N frames of test ROM

### 3.7 Phase 7: DMA
Files:
- (Optional) DmaController.cs or integrate into Mmu
- Support write to 0xFF46: copy from XX00–XX9F to FE00–FE9F

Key Methods:
- Trigger blocking for ~640 cycles (CPU read/write limitations—initially skip blocking, add later)
- Ensure OAM unusable during mode 2/3 (refinements later)

Testing:
- Mooneye dma tests
- Unit: verify copy semantics

### 3.8 Phase 8: Joypad
Files:
- Joypad.cs (add selection bits)
- Integrate to 0xFF00

Key Methods:
- Read: combine row selection bits with current input
- On rising edge of button press: request Joypad interrupt (if enabled)

Testing:
- Mooneye joypad_interrupt
- Manual: key mapping in Blazor

### 3.9 Phase 9: Serial (Stub)
Files:
- SerialPort.cs

Key Methods:
- Map SB (FF01), SC (FF02)
- On start bit set, schedule completion; request Serial interrupt

Testing:
- Unit: writing start triggers interrupt
- Minimal – many ROMs ignore

### 3.10 Phase 10: APU (Audio)
Files:
- Apu.cs
- Square1.cs, Square2.cs, Wave.cs, Noise.cs
- FrameSequencer inside APU
- Mixing buffer

Key Methods:
- Step(cycles) convert to APU ticks
- Generate samples at target sample rate (e.g. 44.1 kHz)
- Expose PullSamples(int count)

Dependencies:
- MMU (NR10–NR52 registers)
- Blazor JS interop for audio playback (AudioWorklet recommended)

Testing:
- Unit: envelope progression, frequency sweep
- Manual: listen for distortion / timing drift

### 3.11 Phase 11: Persistence
Files:
- Persistence/BatteryStore.cs
- Persistence/SaveStateSerializer.cs

Key Methods:
- On ROM load: attempt to load battery save (localStorage in WASM)
- Save interval or manual trigger
- SaveState: CPU regs, RAM arrays, VRAM, OAM, timers, PPU scanline/mode, APU channel states, MBC state
- Version header in serialized blob

Testing:
- Unit: Round-trip state equality
- Integration: Save mid-game; restore; frame buffer hash check

### 3.12 Phase 12: Debug Tooling
Blazor Files:
- Pages/Debug.razor
- Components: DisassemblyView, MemoryView, RegistersPanel, PpuStatePanel, BreakpointsPanel

Core:
- BreakpointManager.cs
- Disassembler.cs (reuse for UI)
- TraceLogger.cs (ring buffer)

Key Methods:
- Emulator.StepInstruction()
- Emulator.RunUntil(predicate)
- API for memory slices

Testing:
- Unit: disassembly mnemonics vs opcode table
- Manual: breakpoints & stepping

### 3.13 Phase 13: Blazor Frontend Integration
Enhance:
- Pages/Index.razor (pause/run/reset buttons, speed toggle)
- Add: Components/RomLoader.razor, FpsCounter.razor, AudioToggle.razor
- JS: optimize drawFrame (use Uint8Array)
- Input remapping UI
- Touch overlay (mobile)
- Persist last ROM + settings

Testing:
- Manual interaction tests
- Hot reload stability

### 3.14 Phase 14: Automated Testing
Files:
- tests/GameBoy.Tests/
  - CpuInstructionTests.cs
  - TimerTests.cs
  - MbcTests.cs
  - PpuModeTests.cs
  - Integration/BlarggHarness.cs
  - Integration/MooneyeHarness.cs

Harness Logic:
```csharp
for (int frame = 0; frame < 10_000 && !Completed(); frame++)
{
    emulator.StepFrame();
}
Assert.True(Completed(), "Test ROM did not signal success.");
```

### 3.15 Phase 15: Performance & Optimization
Targets:
- > 60 FPS stable, real-time cycle emulation
- Input latency < 1 frame
- Audio latency < 80 ms

Strategies:
1. Reduce allocations in CPU loop
2. Inline frequent small ops (flags) after correctness proven
3. Batching JS interop (frame buffer & audio)
4. Consider AOT for release
5. Cache decoded instruction metadata
6. PPU scanline pipeline micro-optimizations (avoid per-pixel branching)

Profiling:
- Browser Performance tab
- Add simple instrumentation counters (frames/sec, cycles/frame)
- Optional: compile instrumentation flags

### 3.16 Phase 16: Packaging & CI/CD
Tasks:
- GitHub Actions:
  - Build Core
  - Run unit tests (conditional external ROM tests)
  - Publish WASM artifact
- GitHub Pages deploy (Blazor)
- Documentation:
  - README feature matrix
  - docs/Architecture.md
  - docs/Testing.md (ROM acquisition instructions)
  - docs/Performance.md

---

## 4. Test ROM Strategy

| Phase | ROMs |
|-------|------|
| CPU (3) | Blargg: cpu_instrs, instr_timing |
| Timers (5) | Blargg: timer tests |
| Interrupt/PPU (4–6) | Mooneye: intr_timing, lcd_sync |
| PPU Accuracy (6) | dmg-acid2, sprite_priority, window_timing |
| DMA (7) | Mooneye: oam_dma_* |
| Joypad (8) | Mooneye: joypad_interrupt |
| APU (10) | Public chiptune test ROMs (manual audio verification) |

Harness Example:
```csharp
for (int frame = 0; frame < 10_000 && !Completed(); frame++)
{
    emulator.StepFrame();
}
Assert.True(Completed(), "Test ROM did not signal success.");
```

---

## 5. Milestones

| Version | Milestone |
|---------|-----------|
| v0.1 | CPU skeleton + ROM load |
| v0.2 | All core CPU instructions pass Blargg |
| v0.3 | Basic PPU (background + VBlank) |
| v0.4 | Full PPU (sprites/window/palettes) passes acid2 |
| v0.5 | MBC1/3/5 + Joypad + DMA (games boot) |
| v0.6 | Audio channels functional |
| v0.7 | Debugger + Save States |
| v0.8 | Performance (real-time) + AOT |
| v0.9 | UX polish (input remap, touch, persistence) |
| v1.0 | Docs + CI + release |

---

## 6. Immediate Next Steps (Actionable)

Adjusted to reflect Phase 1 progress:
1. Wire Mmu I/O region:
   - Use ReadIoRegister/WriteIoRegister for 0xFF00–0xFF7F, fix IoStart/IoEnd constants or add IoRegs.
   - Verify IF/IE stubs read/write behavior (IF upper bits read as 1; IE at 0xFFFF).
2. Introduce unit test project (GameBoy.Tests) with initial memory tests (echo, unusable, I/O stubs).
3. Keep CPU placeholder; prepare opcode table skeleton in Phase 3.
4. Replace PPU placeholder loop with mode-cycle skeleton in Phase 6 (not blocking Phase 1).
5. Optional: add IoRegs static class to centralize register addresses.

---

## 7. Risk & Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| Timing accuracy early on | Test ROM failures cascade | Isolate CPU correctness first; add PPU later |
| Over-abstracting early | Performance regressions | Start simple; profile before micro-optimization |
| Large JS interop overhead | Low FPS | Batch frame + audio updates |
| APU complexity | Delays release | Defer until CPU/PPU reliable |
| Save state drift | Corrupted loads | Version + checksum state snapshot |
| Test ROM licensing | CI blocked | Require manual placement; conditional tests |

---

## 8. Appendix (Representative Code Snippets)

### 8.1 MMU Word Helpers
```csharp
public ushort ReadWord(ushort addr) =>
    (ushort)(ReadByte(addr) | (ReadByte((ushort)(addr + 1)) << 8));

public void WriteWord(ushort addr, ushort value)
{
    WriteByte(addr, (byte)(value & 0xFF));
    WriteByte((ushort)(addr + 1), (byte)(value >> 8));
}
```

### 8.2 Interrupt Priority
```csharp
public bool TryGetPending(out InterruptType type)
{
    int pending = IF & IE;
    if ((pending & 0x01) != 0) { type = InterruptType.VBlank; return true; }
    if ((pending & 0x02) != 0) { type = InterruptType.LCDStat; return true; }
    if ((pending & 0x04) != 0) { type = InterruptType.Timer; return true; }
    if ((pending & 0x08) != 0) { type = InterruptType.Serial; return true; }
    if ((pending & 0x10) != 0) { type = InterruptType.Joypad; return true; }
    type = default;
    return false;
}
```

### 8.3 Frame Step Loop (Emulator)
```csharp
public bool StepFrame()
{
    const int cyclesPerFrame = 70224;
    int total = 0;
    bool frameReady = false;

    while (total < cyclesPerFrame)
    {
        int c = _cpu.Step();
        _timer.Step(c);
        if (_ppu.Step(c)) frameReady = true;
        ServiceInterrupts();
        total += c;
    }
    return frameReady;
}
```

### 8.4 Blazor Interop Rendering (Conceptual)
```javascript
drawFrame: function(canvasId, w, h, buffer) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(w, h);
  const data = img.data;
  for (let i=0;i<buffer.length;i++) {
    const val = buffer[i]>>>0;
    const idx = i*4;
    data[idx]   = (val >> 16) & 0xFF;
    data[idx+1] = (val >> 8) & 0xFF;
    data[idx+2] = val & 0xFF;
    data[idx+3] = (val >> 24) & 0xFF;
  }
  ctx.putImageData(img, 0, 0);
}
```

### 8.5 Instruction Table Entry
```csharp
Primary[0x3E] = new Instruction("LD A,d8", 2, 8, cpu => {
    cpu.Regs.A = cpu.ReadImm8();
    return 8;
});
```

---

## 9. Summary

Phase 1 is close: the memory map, echo mirroring, unusable region, and post-BIOS defaults are in place, and the emulator frame loop is implemented. To finish Phase 1, wire the I/O region to the existing stubbed register handlers, fix the IoRegs constant reference, and add basic unit tests for memory behavior. Subsequent phases (CPU, interrupts, timers, PPU) can proceed once these are validated.
