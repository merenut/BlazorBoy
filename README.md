# BlazorBoy â€“ End-to-End Development Plan

Author: (Generated by Copilot Space)  
Target: Build a Game Boy (DMG) emulator with a Blazor WebAssembly frontend using the current repository scaffold.  
Status: Phase 1 partially implemented (MMU map + post-BIOS defaults + frame loop). See 3.1 for current status and remaining work.

---

## Table of Contents
1. High-Level Phases
2. Repository & Structure
3. Phase Details  
   3.1 Core Foundations  
   3.2 Cartridge & MBCs  
   3.3 CPU Core  
   3.4 Interrupts  
   3.5 Timers  
   3.6 PPU Pipeline  
   3.7 DMA  
   3.8 Joypad  
   3.9 Serial (Stub)  
   3.10 APU (Audio)  
   3.11 Persistence (Battery / Save States)  
   3.12 Debug Tooling  
   3.13 Blazor Frontend Integration  
   3.14 Automated Testing  
   3.15 Performance & Optimization  
   3.16 Packaging & CI/CD
4. Test ROM Strategy
5. Milestones
6. Immediate Next Steps
7. Risk & Mitigation
8. Appendix (Code Snippets)

## Instruction Set Implementation Status

**ðŸŽ‰ CPU INSTRUCTION SET: 100% COMPLETE**

The Game Boy LR35902 CPU instruction set implementation is **fully complete** as of Phase 3:

- âœ… **Primary Opcodes**: 245/245 valid opcodes implemented (100%)
- âœ… **CB-Prefixed Opcodes**: 256/256 opcodes implemented (100%)
- âœ… **Invalid Opcodes**: All 11 invalid opcodes properly handled
- âœ… **Test Coverage**: 578 tests passing, including comprehensive opcode validation and interrupt test ROM harnesses

For detailed instruction coverage analysis, see:
- [`docs/InstructionCoverageSummary.md`](docs/InstructionCoverageSummary.md) - Quick reference coverage tables by category
- [`docs/InstructionSetArchitecture.md`](docs/InstructionSetArchitecture.md) - Complete coverage tables and implementation details
- [`docs/OpcodeTableImplementation.md`](docs/OpcodeTableImplementation.md) - Technical implementation documentation

**This means the CPU is ready for game execution and no additional instruction implementation is needed.**

## Interrupt Controller Implementation Status

**ðŸŽ‰ INTERRUPT CONTROLLER: 100% COMPLETE**

The Game Boy interrupt system is **fully implemented** with comprehensive hardware-accurate behavior:

- âœ… **All 5 Interrupt Types**: VBlank, LCDStat, Timer, Serial, Joypad with correct priority ordering
- âœ… **IF/IE Register Semantics**: Proper bit masking and hardware-accurate read/write behavior
- âœ… **Edge Cases Implemented**: IME delay, HALT behavior, DI immediate effect, RETI functionality
- âœ… **Integration Complete**: CPU interrupt service routine with 20-cycle timing accuracy
- âœ… **Comprehensive Testing**: 51 interrupt-specific tests covering all APIs and edge cases

**Key Features:**
- Hardware-accurate IF register (0xFF0F) with upper 3 bits forced to 1 on read
- Full 8-bit IE register (0xFFFF) support
- Correct interrupt priority: VBlank > LCDStat > Timer > Serial > Joypad
- EI instruction 1-instruction delay before enabling interrupts
- HALT wakes on pending interrupts even when IME=0
- Complete API for hardware component integration

For complete documentation including API reference, register semantics, edge cases, and usage patterns, see:
[`docs/InterruptController.md`](docs/InterruptController.md)

---

## 1. High-Level Phases

0. Scaffold & Baseline  
1. MMU & Core Constants  
2. Cartridge & MBCs  
3. CPU (Fetch/Decode/Execute)  
4. Interrupt Controller  
5. Timers (DIV/TIMA/TMA/TAC)  
6. PPU (Modes, BG, Window, Sprites)  
7. DMA (OAM DMA)  
8. Joypad Matrix  
9. Serial Stub  
10. APU (Channels 1â€“4)  
11. Persistence (Battery RAM, Save States)  
12. Debugging / Introspection  
13. Blazor Integration Enhancements  
14. Test Harness & ROM Automation  
15. Performance Optimization  
16. Packaging / Docs / CI

---

## 2. Repository & Structure

Current (simplified):
```
src/
  GameBoy.Core/
    Cpu.cs
    Mmu.cs
    Cartridge.cs
    Mbc0.cs
    InterruptController.cs
    Ppu.cs
    Timer.cs
    Emulator.cs
  GameBoy.Blazor/
    Pages/Index.razor
    wwwroot/js/emulator.js (expected, referenced)
tests/
  GameBoy.Tests/ (to create)
```

Planned Additions (core-focused):
```
GameBoy.Core/
  Cart/
    CartridgeHeader.cs
    Mbc1.cs
    Mbc3.cs
    Mbc5.cs
  Cpu/
    OpcodeTable.cs
    Instruction.cs
    Alu.cs
    Disassembler.cs
  Interrupts/
    InterruptController.cs (expanded)
  Ppu/
    Lcdc.cs
    Sprite.cs
    Palette.cs
    Fetcher.cs (optional)
  Apu/
    Apu.cs
    Square1.cs
    Square2.cs
    Wave.cs
    Noise.cs
  Persistence/
    BatteryStore.cs
    SaveStateSerializer.cs
  Debug/
    BreakpointManager.cs
    TraceLogger.cs
```

---

## 3. Phase Details

### 3.1 Phase 1: Core Foundations (MMU & Boot State)

Files:
- Mmu.cs (expand I/O mapping stubs)
- IoRegisters (static class of consts) â€“ optional
- BootRom.cs (optional; skip and emulate post-BIOS state)
- Emulator.cs (frame orchestration later)

Key Methods:
- Mmu.ReadByte / WriteByte (add word helpers)
- Handle echo RAM mirroring (E000â€“FDFF â†’ C000â€“DDFF)
- Reserve areas: unusable 0xFEA0â€“0xFEFF
- Add stub I/O register handling (FF00, FF04â€“07, FF0F, FF40â€“FF4B, FF46, FF47â€“49, FF4D reserved later)

Dependencies:
- Cartridge for ROM reads
- Future: Timer/PPU/InterruptController for I/O

Testing:
- Unit tests for memory regions, echo, and restricted zones.

**Phase 1: COMPLETE** (as of 2025-09-08)

All Phase 1 requirements have been implemented and tested:
- âœ… Echo RAM mirroring E000â€“FDFF â†’ C000â€“DDFF (Mmu.ReadByte/WriteByte).
- âœ… Unusable region 0xFEA0â€“0xFEFF returns 0xFF; writes ignored.
- âœ… I/O region wiring: ReadByte calls ReadIoRegister, WriteByte calls WriteIoRegister.
- âœ… IoRegs class provides all I/O register constants; Mmu uses them correctly.
- âœ… IF/IE register semantics: IF upper 3 bits forced to 1s, IE full 8-bit read/write.
- âœ… Post-BIOS defaults initialized (InitializePostBiosDefaults) with proper backing fields.
- âœ… Word helpers ReadWord/WriteWord implemented.
- âœ… ROM access via Cartridge.ReadRom and Cartridge.Detect (MBC0 only).
- âœ… Emulator frame loop accumulates cycles toward 70224 per frame (Emulator.StepFrame).
- âœ… Complete unit test coverage: 39 tests passing (Echo RAM, unusable region, I/O stubs, etc.)

Checklist to close Phase 1:
- [x] Add IoRegs class or correct Mmu.IoStart/InterruptEnable constants.
- [x] Route I/O reads to ReadIoRegister in Mmu.ReadByte.
- [x] Route I/O writes to WriteIoRegister in Mmu.WriteByte.
- [x] Verify IF (0xFF0F) and IE (0xFFFF) read/write semantics match stub masks noted in code.
- [x] Add minimal unit tests:
  - [x] Echo mirroring (E000â€“FDFF mirrors C000â€“DDFF)
  - [x] Unusable region returns 0xFF and ignores writes
  - [x] JOYP lower nibble read as 1s; DIV write clears; IF upper bits read as 1s
  - [x] IE at 0xFFFF read/write round-trips

### 3.2 Phase 2: Cartridge & MBCs
Files:
- Cartridge.cs (expand Detect logic)
- CartridgeHeader.cs (parse metadata at 0x0100â€“0x014F)
- Mbc1.cs, Mbc3.cs, Mbc5.cs (prioritize these)
- Interface: `IBatteryBacked`

Key Methods:
- Bank switching: ROM and external RAM
- MBC1: ROM bank low 5 bits, RAM enable, mode switch
- MBC3: RTC stub (defer full)
- MBC5: 9-bit ROM bank, large RAM layout
- Cartridge.Detect: instantiate correct subclass based on type byte
- Load/Save External RAM

Testing:
- Unit: synthetic ROM arrays with known bank markers
- Integration: simple test ROM that reads from switched banks

### 3.3 Phase 3: CPU Core Implementation
Files:
- Cpu.cs (replace placeholder)
- OpcodeTable.cs
- Instruction.cs (struct { string Mnemonic; int Length; int BaseCycles; Func<Cpu,int> Execute; })
- Alu.cs (flag helpers)
- Disassembler.cs

Key Methods:
- Cpu.Step(): fetch, decode, execute, return cycles
- Implement instruction groups incrementally:
  1. NOP/LD immediate/register loads
  2. INC/DEC/16-bit ops
  3. ALU (ADD/ADC/SUB/SBC/AND/OR/XOR/CP)
  4. Rotates/Shifts + CB prefix
  5. BIT/RES/SET
  6. Control flow (JR, JP, CALL, RET, RST)
  7. Misc (DAA, CPL, SCF, CCF, HALT/STOP, EI/DI)

Dependencies:
- MMU
- InterruptController (Enable/Disable logic; IME delay after EI)

Testing:
- Blargg cpu_instrs (core)
- Unit: DAA edge cases, flag correctness
- Regression: hash of registers at checkpoints

### 3.4 Phase 4: Interrupt Controller
Files:
- InterruptController.cs (expand with IF/IE representation)
- Enum InterruptType { VBlank, LCDStat, Timer, Serial, Joypad }

Key Methods:
- Request(InterruptType)
- Service(Cpu) (push PC, jump vector, clear IF bit)
- Memory mapping: IF @0xFF0F, IE @0xFFFF

Dependencies:
- CPU calls Check after each instruction
- PPU, Timer, Joypad trigger requests

Testing:
- Synthetic: raise multiple interrupts, assert priority order
- Integration: Blargg interrupt test

**Status**: âœ… **COMPLETE** - Interrupt controller fully implemented with comprehensive test coverage.

For detailed documentation, see [`docs/InterruptController.md`](docs/InterruptController.md).

### 3.5 Phase 5: Timers
Files:
- Timer.cs (add internal counters)
- Integrate with Mmu for FF04â€“FF07

Key Methods:
- Step(cycles)
- DIV increments at 16384 Hz
- TIMA increments at selected frequency (TAC lower bits)
- Overflow: set TIMA = TMA, request Timer interrupt (simulate timing subtly later)

Testing:
- Blargg timer test
- Unit: frequency mapping table correctness

### 3.6 Phase 6: PPU Pipeline
Files:
- Ppu.cs (full state machine)
- Lcdc.cs (bit decode for LCDC)
- Sprite.cs (OAM entry)
- Palette.cs
- Optional: Pixel FIFO, Fetcher.cs
- Constants for mode durations

Key Methods:
- Step(cycles): manage modes 0â€“3 + VBlank
- Render background per scanline
- Window layer
- OAM scan (10 sprite limit per line)
- Compositing order (OBJ priority & palette)
- Expose FrameBuffer (int[] RGBA)

Dependencies:
- Mmu for VRAM/OAM/Registers
- InterruptController for VBlank & STAT

Testing:
- Mooneye: lcd_sync, sprite_priority
- Visual: dmg-acid2 (goal image)
- Frame hash after N frames of test ROM

### 3.7 Phase 7: DMA
Files:
- (Optional) DmaController.cs or integrate into Mmu
- Support write to 0xFF46: copy from XX00â€“XX9F to FE00â€“FE9F

Key Methods:
- Trigger blocking for ~640 cycles (CPU read/write limitationsâ€”initially skip blocking, add later)
- Ensure OAM unusable during mode 2/3 (refinements later)

Testing:
- Mooneye dma tests
- Unit: verify copy semantics

### 3.8 Phase 8: Joypad
Files:
- Joypad.cs (add selection bits)
- Integrate to 0xFF00

Key Methods:
- Read: combine row selection bits with current input
- On rising edge of button press: request Joypad interrupt (if enabled)

Testing:
- Mooneye joypad_interrupt
- Manual: key mapping in Blazor

### 3.9 Phase 9: Serial (Stub)
Files:
- SerialPort.cs

Key Methods:
- Map SB (FF01), SC (FF02)
- On start bit set, schedule completion; request Serial interrupt

Testing:
- Unit: writing start triggers interrupt
- Minimal â€“ many ROMs ignore

### 3.10 Phase 10: APU (Audio)
Files:
- Apu.cs
- Square1.cs, Square2.cs, Wave.cs, Noise.cs
- FrameSequencer inside APU
- Mixing buffer

Key Methods:
- Step(cycles) convert to APU ticks
- Generate samples at target sample rate (e.g. 44.1 kHz)
- Expose PullSamples(int count)

Dependencies:
- MMU (NR10â€“NR52 registers)
- Blazor JS interop for audio playback (AudioWorklet recommended)

Testing:
- Unit: envelope progression, frequency sweep
- Manual: listen for distortion / timing drift

### 3.11 Phase 11: Persistence
Files:
- Persistence/BatteryStore.cs
- Persistence/SaveStateSerializer.cs

Key Methods:
- On ROM load: attempt to load battery save (localStorage in WASM)
- Save interval or manual trigger
- SaveState: CPU regs, RAM arrays, VRAM, OAM, timers, PPU scanline/mode, APU channel states, MBC state
- Version header in serialized blob

Testing:
- Unit: Round-trip state equality
- Integration: Save mid-game; restore; frame buffer hash check

### 3.12 Phase 12: Debug Tooling
Blazor Files:
- Pages/Debug.razor
- Components: DisassemblyView, MemoryView, RegistersPanel, PpuStatePanel, BreakpointsPanel

Core:
- BreakpointManager.cs
- Disassembler.cs (reuse for UI)
- TraceLogger.cs (ring buffer)

Key Methods:
- Emulator.StepInstruction()
- Emulator.RunUntil(predicate)
- API for memory slices

Testing:
- Unit: disassembly mnemonics vs opcode table
- Manual: breakpoints & stepping

### 3.13 Phase 13: Blazor Frontend Integration
Enhance:
- Pages/Index.razor (pause/run/reset buttons, speed toggle)
- Add: Components/RomLoader.razor, FpsCounter.razor, AudioToggle.razor
- JS: optimize drawFrame (use Uint8Array)
- Input remapping UI
- Touch overlay (mobile)
- Persist last ROM + settings

Testing:
- Manual interaction tests
- Hot reload stability

### 3.14 Phase 14: Automated Testing
Files:
- tests/GameBoy.Tests/
  - CpuInstructionTests.cs
  - TimerTests.cs
  - MbcTests.cs
  - PpuModeTests.cs
  - Integration/BlarggHarness.cs
  - Integration/MooneyeHarness.cs

Harness Logic:
```csharp
for (int frame = 0; frame < 10_000 && !Completed(); frame++)
{
    emulator.StepFrame();
}
Assert.True(Completed(), "Test ROM did not signal success.");
```

### 3.15 Phase 15: Performance & Optimization
Targets:
- > 60 FPS stable, real-time cycle emulation
- Input latency < 1 frame
- Audio latency < 80 ms

Strategies:
1. Reduce allocations in CPU loop
2. Inline frequent small ops (flags) after correctness proven
3. Batching JS interop (frame buffer & audio)
4. Consider AOT for release
5. Cache decoded instruction metadata
6. PPU scanline pipeline micro-optimizations (avoid per-pixel branching)

Profiling:
- Browser Performance tab
- Add simple instrumentation counters (frames/sec, cycles/frame)
- Optional: compile instrumentation flags

### 3.16 Phase 16: Packaging & CI/CD
Tasks:
- GitHub Actions:
  - Build Core
  - Run unit tests (conditional external ROM tests)
  - Publish WASM artifact
- GitHub Pages deploy (Blazor)
- Documentation:
  - README feature matrix
  - docs/Architecture.md
  - docs/Testing.md (ROM acquisition instructions)
  - docs/Performance.md

---

## 4. Test ROM Strategy

| Phase | ROMs |
|-------|------|
| CPU (3) | Blargg: cpu_instrs, instr_timing |
| Timers (5) | Blargg: timer tests |
| Interrupt/PPU (4â€“6) | Mooneye: intr_timing, lcd_sync |
| PPU Accuracy (6) | dmg-acid2, sprite_priority, window_timing |
| DMA (7) | Mooneye: oam_dma_* |
| Joypad (8) | Mooneye: joypad_interrupt |
| APU (10) | Public chiptune test ROMs (manual audio verification) |

Harness Example:
```csharp
for (int frame = 0; frame < 10_000 && !Completed(); frame++)
{
    emulator.StepFrame();
}
Assert.True(Completed(), "Test ROM did not signal success.");
```

---

## 5. Milestones

| Version | Milestone |
|---------|-----------|
| v0.1 | CPU skeleton + ROM load |
| v0.2 | All core CPU instructions pass Blargg |
| v0.3 | Basic PPU (background + VBlank) |
| v0.4 | Full PPU (sprites/window/palettes) passes acid2 |
| v0.5 | MBC1/3/5 + Joypad + DMA (games boot) |
| v0.6 | Audio channels functional |
| v0.7 | Debugger + Save States |
| v0.8 | Performance (real-time) + AOT |
| v0.9 | UX polish (input remap, touch, persistence) |
| v1.0 | Docs + CI + release |

---

## 6. Immediate Next Steps (Actionable)

Adjusted to reflect Phase 1 progress:
1. Wire Mmu I/O region:
   - Use ReadIoRegister/WriteIoRegister for 0xFF00â€“0xFF7F, fix IoStart/IoEnd constants or add IoRegs.
   - Verify IF/IE stubs read/write behavior (IF upper bits read as 1; IE at 0xFFFF).
2. Introduce unit test project (GameBoy.Tests) with initial memory tests (echo, unusable, I/O stubs).
3. Keep CPU placeholder; prepare opcode table skeleton in Phase 3.
4. Replace PPU placeholder loop with mode-cycle skeleton in Phase 6 (not blocking Phase 1).
5. Optional: add IoRegs static class to centralize register addresses.

---

## 7. Risk & Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| Timing accuracy early on | Test ROM failures cascade | Isolate CPU correctness first; add PPU later |
| Over-abstracting early | Performance regressions | Start simple; profile before micro-optimization |
| Large JS interop overhead | Low FPS | Batch frame + audio updates |
| APU complexity | Delays release | Defer until CPU/PPU reliable |
| Save state drift | Corrupted loads | Version + checksum state snapshot |
| Test ROM licensing | CI blocked | Require manual placement; conditional tests |

---

## 8. Appendix (Representative Code Snippets)

### 8.1 MMU Word Helpers
```csharp
public ushort ReadWord(ushort addr) =>
    (ushort)(ReadByte(addr) | (ReadByte((ushort)(addr + 1)) << 8));

public void WriteWord(ushort addr, ushort value)
{
    WriteByte(addr, (byte)(value & 0xFF));
    WriteByte((ushort)(addr + 1), (byte)(value >> 8));
}
```

### 8.2 Interrupt Priority
```csharp
public bool TryGetPending(out InterruptType type)
{
    int pending = IF & IE;
    if ((pending & 0x01) != 0) { type = InterruptType.VBlank; return true; }
    if ((pending & 0x02) != 0) { type = InterruptType.LCDStat; return true; }
    if ((pending & 0x04) != 0) { type = InterruptType.Timer; return true; }
    if ((pending & 0x08) != 0) { type = InterruptType.Serial; return true; }
    if ((pending & 0x10) != 0) { type = InterruptType.Joypad; return true; }
    type = default;
    return false;
}
```

### 8.3 Frame Step Loop (Emulator)
```csharp
public bool StepFrame()
{
    const int cyclesPerFrame = 70224;
    int total = 0;
    bool frameReady = false;

    while (total < cyclesPerFrame)
    {
        int c = _cpu.Step();
        _timer.Step(c);
        if (_ppu.Step(c)) frameReady = true;
        ServiceInterrupts();
        total += c;
    }
    return frameReady;
}
```

### 8.4 Blazor Interop Rendering (Conceptual)
```javascript
drawFrame: function(canvasId, w, h, buffer) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(w, h);
  const data = img.data;
  for (let i=0;i<buffer.length;i++) {
    const val = buffer[i]>>>0;
    const idx = i*4;
    data[idx]   = (val >> 16) & 0xFF;
    data[idx+1] = (val >> 8) & 0xFF;
    data[idx+2] = val & 0xFF;
    data[idx+3] = (val >> 24) & 0xFF;
  }
  ctx.putImageData(img, 0, 0);
}
```

### 8.5 Instruction Table Entry
```csharp
Primary[0x3E] = new Instruction("LD A,d8", 2, 8, cpu => {
    cpu.Regs.A = cpu.ReadImm8();
    return 8;
});
```

---

## 9. Summary

Phase 1 is close: the memory map, echo mirroring, unusable region, and post-BIOS defaults are in place, and the emulator frame loop is implemented. To finish Phase 1, wire the I/O region to the existing stubbed register handlers, fix the IoRegs constant reference, and add basic unit tests for memory behavior. Subsequent phases (CPU, interrupts, timers, PPU) can proceed once these are validated.
